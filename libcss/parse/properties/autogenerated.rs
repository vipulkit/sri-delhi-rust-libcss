/*
 * This file was generated by LibCSS css_property_parser_gen 
 * Mozilla Samsung Servo Browser Project.
 */


use stylesheet::*;
use parse::propstrings::*;
use include::properties::*;
use parse::properties::common::*;
use utils::errors::*;
use lex::lexer::*;
use wapcaplet::*;
use bytecode::opcodes::*;
use bytecode::bytecode::*;
use include::fpmath::*;

/**
 * #Generated from:
 *
 *     background_repeat:CSS_PROP_BACKGROUND_REPEAT IDENT:( INHERIT: NO_REPEAT:0,BACKGROUND_REPEAT_NO_REPEAT REPEAT_X:0,BACKGROUND_REPEAT_REPEAT_X REPEAT_Y:0,BACKGROUND_REPEAT_REPEAT_Y REPEAT:0,BACKGROUND_REPEAT_REPEAT IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_background_repeat(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_REPEAT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NO_REPEAT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_REPEAT, 0,BACKGROUND_REPEAT_NO_REPEAT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), REPEAT_X as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_REPEAT, 0,BACKGROUND_REPEAT_REPEAT_X)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), REPEAT_Y as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_REPEAT, 0,BACKGROUND_REPEAT_REPEAT_Y)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), REPEAT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_REPEAT, 0,BACKGROUND_REPEAT_REPEAT)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     border_collapse:CSS_PROP_BORDER_COLLAPSE IDENT:( INHERIT: COLLAPSE:0,BORDER_COLLAPSE_COLLAPSE SEPARATE:0,BORDER_COLLAPSE_SEPARATE IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_border_collapse(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BORDER_COLLAPSE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), COLLAPSE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BORDER_COLLAPSE, 0,BORDER_COLLAPSE_COLLAPSE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SEPARATE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BORDER_COLLAPSE, 0,BORDER_COLLAPSE_SEPARATE)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     cue_after:CSS_PROP_CUE_AFTER IDENT:( INHERIT: NONE:0,CUE_AFTER_NONE IDENT:) URI:CUE_AFTER_URI
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_cue_after(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	(match token.token_type { CSS_TOKEN_URI => false, _ => true}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_CUE_AFTER)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_CUE_AFTER, 0,CUE_AFTER_NONE)
	} 
	else  if match token.token_type { CSS_TOKEN_URI => true, _ => false} {

		match (*sheet.resolve)(copy sheet.url, token.idata.get_ref().clone()) {
			(CSS_OK, Some(uri)) => {
				let uri_snumber = sheet.css__stylesheet_string_add(lwc_string_data(uri));
				css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_CUE_AFTER, 0, CUE_AFTER_URI );
				css_stylesheet::css__stylesheet_style_append(result, uri_snumber as u32)

			},
			(error, _ ) => {
				*ctx = orig_ctx;
				return error
			},
		}

	} 
	 else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     cue_before:CSS_PROP_CUE_BEFORE IDENT:( INHERIT: NONE:0,CUE_BEFORE_NONE IDENT:) URI:CUE_BEFORE_URI
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_cue_before(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	(match token.token_type { CSS_TOKEN_URI => false, _ => true}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_CUE_BEFORE)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_CUE_BEFORE, 0,CUE_BEFORE_NONE)
	} 
	else  if match token.token_type { CSS_TOKEN_URI => true, _ => false} {

		match (*sheet.resolve)(copy sheet.url, token.idata.get_ref().clone()) {
			(CSS_OK, Some(uri)) => {
				let uri_snumber = sheet.css__stylesheet_string_add(lwc_string_data(uri));
				css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_CUE_BEFORE, 0, CUE_BEFORE_URI );
				css_stylesheet::css__stylesheet_style_append(result, uri_snumber as u32)

			},
			(error, _ ) => {
				*ctx = orig_ctx;
				return error
			},
		}

	} 
	 else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     direction:CSS_PROP_DIRECTION IDENT:( INHERIT: LTR:0,DIRECTION_LTR RTL:0,DIRECTION_RTL IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_direction(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_DIRECTION)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LTR as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DIRECTION, 0,DIRECTION_LTR)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RTL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DIRECTION, 0,DIRECTION_RTL)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     display:CSS_PROP_DISPLAY IDENT:( INHERIT: INLINE:0,DISPLAY_INLINE BLOCK:0,DISPLAY_BLOCK LIST_ITEM:0,DISPLAY_LIST_ITEM RUN_IN:0,DISPLAY_RUN_IN INLINE_BLOCK:0,DISPLAY_INLINE_BLOCK TABLE:0,DISPLAY_TABLE INLINE_TABLE:0,DISPLAY_INLINE_TABLE TABLE_ROW_GROUP:0,DISPLAY_TABLE_ROW_GROUP TABLE_HEADER_GROUP:0,DISPLAY_TABLE_HEADER_GROUP TABLE_FOOTER_GROUP:0,DISPLAY_TABLE_FOOTER_GROUP TABLE_ROW:0,DISPLAY_TABLE_ROW TABLE_COLUMN_GROUP:0,DISPLAY_TABLE_COLUMN_GROUP TABLE_COLUMN:0,DISPLAY_TABLE_COLUMN TABLE_CELL:0,DISPLAY_TABLE_CELL TABLE_CAPTION:0,DISPLAY_TABLE_CAPTION NONE:0,DISPLAY_NONE IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_display(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_DISPLAY)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INLINE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0,DISPLAY_INLINE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), BLOCK as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0,DISPLAY_BLOCK)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LIST_ITEM as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0,DISPLAY_LIST_ITEM)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RUN_IN as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0,DISPLAY_RUN_IN)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INLINE_BLOCK as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0,DISPLAY_INLINE_BLOCK)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), TABLE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0,DISPLAY_TABLE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INLINE_TABLE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0,DISPLAY_INLINE_TABLE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), TABLE_ROW_GROUP as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0,DISPLAY_TABLE_ROW_GROUP)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), TABLE_HEADER_GROUP as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0,DISPLAY_TABLE_HEADER_GROUP)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), TABLE_FOOTER_GROUP as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0,DISPLAY_TABLE_FOOTER_GROUP)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), TABLE_ROW as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0,DISPLAY_TABLE_ROW)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), TABLE_COLUMN_GROUP as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0,DISPLAY_TABLE_COLUMN_GROUP)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), TABLE_COLUMN as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0,DISPLAY_TABLE_COLUMN)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), TABLE_CELL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0,DISPLAY_TABLE_CELL)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), TABLE_CAPTION as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0,DISPLAY_TABLE_CAPTION)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_DISPLAY, 0,DISPLAY_NONE)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     empty_cells:CSS_PROP_EMPTY_CELLS IDENT:( INHERIT: SHOW:0,EMPTY_CELLS_SHOW HIDE:0,EMPTY_CELLS_HIDE IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_empty_cells(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_EMPTY_CELLS)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SHOW as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_EMPTY_CELLS, 0,EMPTY_CELLS_SHOW)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), HIDE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_EMPTY_CELLS, 0,EMPTY_CELLS_HIDE)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     float:CSS_PROP_FLOAT IDENT:( INHERIT: LEFT:0,FLOAT_LEFT RIGHT:0,FLOAT_RIGHT NONE:0,FLOAT_NONE IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_float(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_FLOAT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LEFT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FLOAT, 0,FLOAT_LEFT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RIGHT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FLOAT, 0,FLOAT_RIGHT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FLOAT, 0,FLOAT_NONE)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     font_size:CSS_PROP_FONT_SIZE IDENT:( INHERIT: XX_SMALL:0,FONT_SIZE_XX_SMALL X_SMALL:0,FONT_SIZE_X_SMALL SMALL:0,FONT_SIZE_SMALL MEDIUM:0,FONT_SIZE_MEDIUM LARGE:0,FONT_SIZE_LARGE X_LARGE:0,FONT_SIZE_X_LARGE XX_LARGE:0,FONT_SIZE_XX_LARGE LARGER:0,FONT_SIZE_LARGER SMALLER:0,FONT_SIZE_SMALLER IDENT:) LENGTH_UNIT:( UNIT_PX:FONT_SIZE_DIMENSION DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) RANGE:<0 LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_font_size(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_FONT_SIZE)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), XX_SMALL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0,FONT_SIZE_XX_SMALL)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), X_SMALL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0,FONT_SIZE_X_SMALL)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SMALL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0,FONT_SIZE_SMALL)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), MEDIUM as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0,FONT_SIZE_MEDIUM)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LARGE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0,FONT_SIZE_LARGE)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), X_LARGE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0,FONT_SIZE_X_LARGE)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), XX_LARGE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0,FONT_SIZE_XX_LARGE)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LARGER as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0,FONT_SIZE_LARGER)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SMALLER as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0,FONT_SIZE_SMALLER)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		if (unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_SIZE, 0, FONT_SIZE_DIMENSION);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     font_style:CSS_PROP_FONT_STYLE IDENT:( INHERIT: NORMAL:0,FONT_STYLE_NORMAL ITALIC:0,FONT_STYLE_ITALIC OBLIQUE:0,FONT_STYLE_OBLIQUE IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_font_style(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_FONT_STYLE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NORMAL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_STYLE, 0,FONT_STYLE_NORMAL)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), ITALIC as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_STYLE, 0,FONT_STYLE_ITALIC)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), OBLIQUE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_STYLE, 0,FONT_STYLE_OBLIQUE)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     font_variant:CSS_PROP_FONT_VARIANT IDENT:( INHERIT: NORMAL:0,FONT_VARIANT_NORMAL SMALL_CAPS:0,FONT_VARIANT_SMALL_CAPS IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_font_variant(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_FONT_VARIANT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NORMAL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_VARIANT, 0,FONT_VARIANT_NORMAL)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SMALL_CAPS as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_FONT_VARIANT, 0,FONT_VARIANT_SMALL_CAPS)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     height:CSS_PROP_HEIGHT IDENT:( INHERIT: AUTO:0,HEIGHT_AUTO IDENT:) LENGTH_UNIT:( UNIT_PX:HEIGHT_SET DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) RANGE:<0 LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_height(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_HEIGHT)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_HEIGHT, 0,HEIGHT_AUTO)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		if (unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_HEIGHT, 0, HEIGHT_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     letter_spacing:CSS_PROP_LETTER_SPACING IDENT:( INHERIT: NORMAL:0,LETTER_SPACING_NORMAL IDENT:) LENGTH_UNIT:( UNIT_PX:LETTER_SPACING_SET DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0)||unit&UNIT_PCT LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_letter_spacing(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_LETTER_SPACING)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NORMAL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_LETTER_SPACING, 0,LETTER_SPACING_NORMAL)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_LETTER_SPACING, 0, LETTER_SPACING_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     line_height:CSS_PROP_LINE_HEIGHT IDENT:( INHERIT: NORMAL:0,LINE_HEIGHT_NORMAL IDENT:) NUMBER:( false:LINE_HEIGHT_NUMBER RANGE:num<0 NUMBER:) LENGTH_UNIT:( UNIT_PX:LINE_HEIGHT_DIMENSION DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) RANGE:<0 LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_line_height(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_LINE_HEIGHT)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NORMAL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_LINE_HEIGHT, 0,LINE_HEIGHT_NORMAL)
	} 
	else 	if match token.token_type { CSS_TOKEN_NUMBER => true, _ => false} {
		let mut (num,consumed): (i32,uint)=  css__number_from_lwc_string(token.idata.get_ref().clone(), false);
		/* Invalid if there are trailing characters */
		if consumed != lwc_string_length(token.idata.get_ref().clone()) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_LINE_HEIGHT, 0, LINE_HEIGHT_NUMBER);
		css_stylesheet::css__stylesheet_style_append(result, num as u32)
	} 
	 else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		if (unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_LINE_HEIGHT, 0, LINE_HEIGHT_DIMENSION);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     max_height:CSS_PROP_MAX_HEIGHT IDENT:( INHERIT: NONE:0,MAX_HEIGHT_NONE IDENT:) LENGTH_UNIT:( UNIT_PX:MAX_HEIGHT_SET DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) RANGE:<0 LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_max_height(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_MAX_HEIGHT)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_MAX_HEIGHT, 0,MAX_HEIGHT_NONE)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		if (unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_MAX_HEIGHT, 0, MAX_HEIGHT_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     max_width:CSS_PROP_MAX_WIDTH IDENT:( INHERIT: NONE:0,MAX_WIDTH_NONE IDENT:) LENGTH_UNIT:( UNIT_PX:MAX_WIDTH_SET DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) RANGE:<0 LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_max_width(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_MAX_WIDTH)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_MAX_WIDTH, 0,MAX_WIDTH_NONE)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		if (unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_MAX_WIDTH, 0, MAX_WIDTH_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     min_height:CSS_PROP_MIN_HEIGHT IDENT:INHERIT LENGTH_UNIT:( UNIT_PX:MIN_HEIGHT_SET DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) RANGE:<0 LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_min_height(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_MIN_HEIGHT)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		if (unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_MIN_HEIGHT, 0, MIN_HEIGHT_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     min_width:CSS_PROP_MIN_WIDTH IDENT:INHERIT LENGTH_UNIT:( UNIT_PX:MIN_WIDTH_SET DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) RANGE:<0 LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_min_width(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_MIN_WIDTH)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		if (unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_MIN_WIDTH, 0, MIN_WIDTH_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     color:CSS_PROP_COLOR IDENT:INHERIT COLOR:COLOR_SET
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_color(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_COLOR)
	} 
	else 	{
		*ctx = orig_ctx;

		let mut value:u16;

		let mut color:u32;

		let (value_option, color_option, res)= css__parse_color_specifier(sheet, strings, vector, ctx);
		match res {
			CSS_OK => {
				value = value_option.unwrap();
				color = color_option.unwrap() },
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLOR, 0, value);

		if value == COLOR_SET {
			css_stylesheet::css__stylesheet_style_append(result, color as u32)
		}
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     padding_side:op GENERIC: IDENT:INHERIT LENGTH_UNIT:( UNIT_PX:PADDING_SET DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0)  RANGE:<0 LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
 * 'op' - Bytecode OpCode for CSS property to encode* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_padding_side(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style, op:css_properties_e) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, op)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		if (unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0, PADDING_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     padding_bottom:CSS_PROP_PADDING_BOTTOM WRAP:css__parse_padding_side
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_padding_bottom(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_padding_side(sheet, strings, vector, ctx, result, CSS_PROP_PADDING_BOTTOM)
}
/**
 * #Generated from:
 *
 *     padding_left:CSS_PROP_PADDING_LEFT WRAP:css__parse_padding_side
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_padding_left(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_padding_side(sheet, strings, vector, ctx, result, CSS_PROP_PADDING_LEFT)
}
/**
 * #Generated from:
 *
 *     padding_top:CSS_PROP_PADDING_TOP WRAP:css__parse_padding_side
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_padding_top(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_padding_side(sheet, strings, vector, ctx, result, CSS_PROP_PADDING_TOP)
}
/**
 * #Generated from:
 *
 *     padding_right:CSS_PROP_PADDING_RIGHT WRAP:css__parse_padding_side
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_padding_right(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_padding_side(sheet, strings, vector, ctx, result, CSS_PROP_PADDING_RIGHT)
}
/**
 * #Generated from:
 *
 *     margin_side:op GENERIC IDENT:( INHERIT: AUTO:0,MARGIN_AUTO IDENT:) LENGTH_UNIT:( UNIT_PX:MARGIN_SET DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
 * 'op' - Bytecode OpCode for CSS property to encode* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_margin_side(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style, op:css_properties_e) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, op)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0,MARGIN_AUTO)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0, MARGIN_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     margin_top:CSS_PROP_MARGIN_TOP WRAP:css__parse_margin_side
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_margin_top(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_margin_side(sheet, strings, vector, ctx, result, CSS_PROP_MARGIN_TOP)
}
/**
 * #Generated from:
 *
 *     margin_bottom:CSS_PROP_MARGIN_BOTTOM WRAP:css__parse_margin_side
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_margin_bottom(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_margin_side(sheet, strings, vector, ctx, result, CSS_PROP_MARGIN_BOTTOM)
}
/**
 * #Generated from:
 *
 *     margin_left:CSS_PROP_MARGIN_LEFT WRAP:css__parse_margin_side
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_margin_left(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_margin_side(sheet, strings, vector, ctx, result, CSS_PROP_MARGIN_LEFT)
}
/**
 * #Generated from:
 *
 *     margin_right:CSS_PROP_MARGIN_RIGHT WRAP:css__parse_margin_side
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_margin_right(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_margin_side(sheet, strings, vector, ctx, result, CSS_PROP_MARGIN_RIGHT)
}
/**
 * #Generated from:
 *
 *     side:op GENERIC: IDENT:( INHERIT: AUTO:0,BOTTOM_AUTO IDENT:) LENGTH_UNIT:( UNIT_PX:BOTTOM_SET DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
 * 'op' - Bytecode OpCode for CSS property to encode* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_side(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style, op:css_properties_e) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, op)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0,BOTTOM_AUTO)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0, BOTTOM_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     top:CSS_PROP_TOP WRAP:css__parse_side
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_top(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_side(sheet, strings, vector, ctx, result, CSS_PROP_TOP)
}
/**
 * #Generated from:
 *
 *     bottom:CSS_PROP_BOTTOM WRAP:css__parse_side
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_bottom(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_side(sheet, strings, vector, ctx, result, CSS_PROP_BOTTOM)
}
/**
 * #Generated from:
 *
 *     left:CSS_PROP_LEFT WRAP:css__parse_side
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_left(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_side(sheet, strings, vector, ctx, result, CSS_PROP_LEFT)
}
/**
 * #Generated from:
 *
 *     right:CSS_PROP_RIGHT WRAP:css__parse_side
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_right(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_side(sheet, strings, vector, ctx, result, CSS_PROP_RIGHT)
}
/**
 * #Generated from:
 *
 *     border_side_width:op GENERIC: IDENT:( INHERIT: THIN:0,BORDER_WIDTH_THIN MEDIUM:0,BORDER_WIDTH_MEDIUM THICK:0,BORDER_WIDTH_THICK IDENT:) LENGTH_UNIT:( UNIT_PX:BORDER_WIDTH_SET DISALLOW:unit==UNIT_PCT||(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) RANGE:<0 LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
 * 'op' - Bytecode OpCode for CSS property to encode* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_border_side_width(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style, op:css_properties_e) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, op)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), THIN as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0,BORDER_WIDTH_THIN)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), MEDIUM as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0,BORDER_WIDTH_MEDIUM)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), THICK as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0,BORDER_WIDTH_THICK)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		if unit==UNIT_PCT||(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0, BORDER_WIDTH_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     border_top_width:CSS_PROP_BORDER_TOP_WIDTH WRAP:css__parse_border_side_width
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_border_top_width(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side_width(sheet, strings, vector, ctx, result, CSS_PROP_BORDER_TOP_WIDTH)
}
/**
 * #Generated from:
 *
 *     border_bottom_width:CSS_PROP_BORDER_BOTTOM_WIDTH WRAP:css__parse_border_side_width
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_border_bottom_width(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side_width(sheet, strings, vector, ctx, result, CSS_PROP_BORDER_BOTTOM_WIDTH)
}
/**
 * #Generated from:
 *
 *     border_left_width:CSS_PROP_BORDER_LEFT_WIDTH WRAP:css__parse_border_side_width
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_border_left_width(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side_width(sheet, strings, vector, ctx, result, CSS_PROP_BORDER_LEFT_WIDTH)
}
/**
 * #Generated from:
 *
 *     border_right_width:CSS_PROP_BORDER_RIGHT_WIDTH WRAP:css__parse_border_side_width
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_border_right_width(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side_width(sheet, strings, vector, ctx, result, CSS_PROP_BORDER_RIGHT_WIDTH)
}
/**
 * #Generated from:
 *
 *     border_side_style:op GENERIC: IDENT:( INHERIT: NONE:0,BORDER_STYLE_NONE HIDDEN:0,BORDER_STYLE_HIDDEN DOTTED:0,BORDER_STYLE_DOTTED DASHED:0,BORDER_STYLE_DASHED SOLID:0,BORDER_STYLE_SOLID LIBCSS_DOUBLE:0,BORDER_STYLE_DOUBLE GROOVE:0,BORDER_STYLE_GROOVE RIDGE:0,BORDER_STYLE_RIDGE INSET:0,BORDER_STYLE_INSET OUTSET:0,BORDER_STYLE_OUTSET IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
 * 'op' - Bytecode OpCode for CSS property to encode* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_border_side_style(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style, op:css_properties_e) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, op)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0,BORDER_STYLE_NONE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), HIDDEN as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0,BORDER_STYLE_HIDDEN)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), DOTTED as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0,BORDER_STYLE_DOTTED)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), DASHED as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0,BORDER_STYLE_DASHED)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SOLID as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0,BORDER_STYLE_SOLID)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LIBCSS_DOUBLE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0,BORDER_STYLE_DOUBLE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), GROOVE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0,BORDER_STYLE_GROOVE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RIDGE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0,BORDER_STYLE_RIDGE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INSET as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0,BORDER_STYLE_INSET)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), OUTSET as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0,BORDER_STYLE_OUTSET)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     border_top_style:CSS_PROP_BORDER_TOP_STYLE WRAP:css__parse_border_side_style
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_border_top_style(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side_style(sheet, strings, vector, ctx, result, CSS_PROP_BORDER_TOP_STYLE)
}
/**
 * #Generated from:
 *
 *     border_bottom_style:CSS_PROP_BORDER_BOTTOM_STYLE WRAP:css__parse_border_side_style
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_border_bottom_style(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side_style(sheet, strings, vector, ctx, result, CSS_PROP_BORDER_BOTTOM_STYLE)
}
/**
 * #Generated from:
 *
 *     border_left_style:CSS_PROP_BORDER_LEFT_STYLE WRAP:css__parse_border_side_style
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_border_left_style(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side_style(sheet, strings, vector, ctx, result, CSS_PROP_BORDER_LEFT_STYLE)
}
/**
 * #Generated from:
 *
 *     border_right_style:CSS_PROP_BORDER_RIGHT_STYLE WRAP:css__parse_border_side_style
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_border_right_style(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side_style(sheet, strings, vector, ctx, result, CSS_PROP_BORDER_RIGHT_STYLE)
}
/**
 * #Generated from:
 *
 *     border_side_color:op GENERIC: IDENT:( INHERIT: IDENT:) COLOR:BORDER_COLOR_SET
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
 * 'op' - Bytecode OpCode for CSS property to encode* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_border_side_color(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style, op:css_properties_e) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, op)
	} 
	else 	{
		*ctx = orig_ctx;

		let mut value:u16;

		let mut color:u32;

		let (value_option, color_option, res)= css__parse_color_specifier(sheet, strings, vector, ctx);
		match res {
			CSS_OK => {
				value = value_option.unwrap();
				color = color_option.unwrap() },
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, op, 0, value);

		if value == COLOR_SET {
			css_stylesheet::css__stylesheet_style_append(result, color as u32)
		}
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     border_top_color:CSS_PROP_BORDER_TOP_COLOR WRAP:css__parse_border_side_color
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_border_top_color(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side_color(sheet, strings, vector, ctx, result, CSS_PROP_BORDER_TOP_COLOR)
}
/**
 * #Generated from:
 *
 *     border_bottom_color:CSS_PROP_BORDER_BOTTOM_COLOR WRAP:css__parse_border_side_color
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_border_bottom_color(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side_color(sheet, strings, vector, ctx, result, CSS_PROP_BORDER_BOTTOM_COLOR)
}
/**
 * #Generated from:
 *
 *     border_left_color:CSS_PROP_BORDER_LEFT_COLOR WRAP:css__parse_border_side_color
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_border_left_color(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side_color(sheet, strings, vector, ctx, result, CSS_PROP_BORDER_LEFT_COLOR)
}
/**
 * #Generated from:
 *
 *     border_right_color:CSS_PROP_BORDER_RIGHT_COLOR WRAP:css__parse_border_side_color
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_border_right_color(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side_color(sheet, strings, vector, ctx, result, CSS_PROP_BORDER_RIGHT_COLOR)
}
/**
 * #Generated from:
 *
 *     counter_increment:CSS_PROP_COUNTER_INCREMENT IDENT:( INHERIT: NONE:0,COUNTER_INCREMENT_NONE IDENT:) IDENT_LIST:( STRING_OPTNUM:COUNTER_INCREMENT_NAMED 1:COUNTER_INCREMENT_NONE IDENT_LIST:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_counter_increment(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_COUNTER_INCREMENT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COUNTER_INCREMENT, 0,COUNTER_INCREMENT_NONE)
	} 
	else {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COUNTER_INCREMENT, 0, COUNTER_INCREMENT_NAMED);
		while (*ctx < vector.len()) && (match (&vector[*ctx]).token_type {CSS_TOKEN_IDENT => true, _ => false}) {
			token=&vector[*ctx];
			let mut num:css_fixed;
			let mut pctx:uint;

			let mut token_null=false;

			let snumber = sheet.css__stylesheet_string_add(lwc_string_data(token.idata.get_ref().clone()));
			css_stylesheet::css__stylesheet_style_append(result, snumber as u32);
			consumeWhitespace(vector, ctx);

			pctx = *ctx;
			if *ctx >= vector.len() {
				token_null = true
			}
			else { 
				token = &vector[*ctx];
				*ctx += 1 //Iterate
			}
			if !token_null && (match token.token_type { CSS_TOKEN_NUMBER => true, _ => false}) {
				let (ret_num, consumed) = css__number_from_lwc_string(token.idata.get_ref().clone(), true);
				if consumed != lwc_string_length(token.idata.get_ref().clone()) {
					*ctx = orig_ctx;
					return CSS_INVALID
				}
				num = css_int_to_fixed(ret_num as int);

				consumeWhitespace(vector, ctx);

				pctx = *ctx;
				if *ctx >= vector.len() {
					token_null = true
				}
				else { 
					token = &vector[*ctx];
					*ctx += 1 //Iterate
				}
			}
			else {
				num = css_int_to_fixed(1)
			}

			css_stylesheet::css__stylesheet_style_append(result, num as u32);
			if token_null {
				break;
}
			if match token.token_type { CSS_TOKEN_IDENT => true, _ => false} {
				css_stylesheet::css__stylesheet_style_append(result, COUNTER_INCREMENT_NAMED as u32);
			}
			else {
				*ctx = pctx // rewind one token back */
			}
		}

		css_stylesheet::css__stylesheet_style_append(result, COUNTER_INCREMENT_NONE as u32)
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     counter_reset:CSS_PROP_COUNTER_RESET IDENT:( INHERIT: NONE:0,COUNTER_RESET_NONE IDENT:) IDENT_LIST:( STRING_OPTNUM:COUNTER_RESET_NAMED 0:COUNTER_RESET_NONE IDENT_LIST:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_counter_reset(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_COUNTER_RESET)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COUNTER_RESET, 0,COUNTER_RESET_NONE)
	} 
	else {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COUNTER_RESET, 0, COUNTER_RESET_NAMED);
		while (*ctx < vector.len()) && (match (&vector[*ctx]).token_type {CSS_TOKEN_IDENT => true, _ => false}) {
			token=&vector[*ctx];
			let mut num:css_fixed;
			let mut pctx:uint;

			let mut token_null=false;

			let snumber = sheet.css__stylesheet_string_add(lwc_string_data(token.idata.get_ref().clone()));
			css_stylesheet::css__stylesheet_style_append(result, snumber as u32);
			consumeWhitespace(vector, ctx);

			pctx = *ctx;
			if *ctx >= vector.len() {
				token_null = true
			}
			else { 
				token = &vector[*ctx];
				*ctx += 1 //Iterate
			}
			if !token_null && (match token.token_type { CSS_TOKEN_NUMBER => true, _ => false}) {
				let (ret_num, consumed) = css__number_from_lwc_string(token.idata.get_ref().clone(), true);
				if consumed != lwc_string_length(token.idata.get_ref().clone()) {
					*ctx = orig_ctx;
					return CSS_INVALID
				}
				num = css_int_to_fixed(ret_num as int);

				consumeWhitespace(vector, ctx);

				pctx = *ctx;
				if *ctx >= vector.len() {
					token_null = true
				}
				else { 
					token = &vector[*ctx];
					*ctx += 1 //Iterate
				}
			}
			else {
				num = css_int_to_fixed(0)
			}

			css_stylesheet::css__stylesheet_style_append(result, num as u32);
			if token_null {
				break;
}
			if match token.token_type { CSS_TOKEN_IDENT => true, _ => false} {
				css_stylesheet::css__stylesheet_style_append(result, COUNTER_RESET_NAMED as u32);
			}
			else {
				*ctx = pctx // rewind one token back */
			}
		}

		css_stylesheet::css__stylesheet_style_append(result, COUNTER_RESET_NONE as u32)
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     background_attachment:CSS_PROP_BACKGROUND_ATTACHMENT IDENT:( INHERIT: FIXED:0,BACKGROUND_ATTACHMENT_FIXED SCROLL:0,BACKGROUND_ATTACHMENT_SCROLL IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_background_attachment(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_ATTACHMENT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), FIXED as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_ATTACHMENT, 0,BACKGROUND_ATTACHMENT_FIXED)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SCROLL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_ATTACHMENT, 0,BACKGROUND_ATTACHMENT_SCROLL)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     background_color:CSS_PROP_BACKGROUND_COLOR IDENT:( INHERIT: IDENT:) COLOR:BACKGROUND_COLOR_SET
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_background_color(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_COLOR)
	} 
	else 	{
		*ctx = orig_ctx;

		let mut value:u16;

		let mut color:u32;

		let (value_option, color_option, res)= css__parse_color_specifier(sheet, strings, vector, ctx);
		match res {
			CSS_OK => {
				value = value_option.unwrap();
				color = color_option.unwrap() },
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_COLOR, 0, value);

		if value == COLOR_SET {
			css_stylesheet::css__stylesheet_style_append(result, color as u32)
		}
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     caption_side:CSS_PROP_CAPTION_SIDE IDENT:( INHERIT: TOP:0,CAPTION_SIDE_TOP BOTTOM:0,CAPTION_SIDE_BOTTOM IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_caption_side(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_CAPTION_SIDE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), TOP as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_CAPTION_SIDE, 0,CAPTION_SIDE_TOP)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), BOTTOM as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_CAPTION_SIDE, 0,CAPTION_SIDE_BOTTOM)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     clear:CSS_PROP_CLEAR IDENT:( INHERIT: RIGHT:0,CLEAR_RIGHT LEFT:0,CLEAR_LEFT BOTH:0,CLEAR_BOTH NONE:0,CLEAR_NONE IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_clear(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_CLEAR)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RIGHT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_CLEAR, 0,CLEAR_RIGHT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LEFT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_CLEAR, 0,CLEAR_LEFT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), BOTH as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_CLEAR, 0,CLEAR_BOTH)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_CLEAR, 0,CLEAR_NONE)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     background_image:CSS_PROP_BACKGROUND_IMAGE IDENT:( INHERIT: NONE:0,BACKGROUND_IMAGE_NONE IDENT:) URI:BACKGROUND_IMAGE_URI
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_background_image(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	(match token.token_type { CSS_TOKEN_URI => false, _ => true}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_IMAGE)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_IMAGE, 0,BACKGROUND_IMAGE_NONE)
	} 
	else  if match token.token_type { CSS_TOKEN_URI => true, _ => false} {

		match (*sheet.resolve)(copy sheet.url, token.idata.get_ref().clone()) {
			(CSS_OK, Some(uri)) => {
				let uri_snumber = sheet.css__stylesheet_string_add(lwc_string_data(uri));
				css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BACKGROUND_IMAGE, 0, BACKGROUND_IMAGE_URI );
				css_stylesheet::css__stylesheet_style_append(result, uri_snumber as u32)

			},
			(error, _ ) => {
				*ctx = orig_ctx;
				return error
			},
		}

	} 
	 else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     list_style_image:CSS_PROP_LIST_STYLE_IMAGE IDENT:( INHERIT: NONE:0,LIST_STYLE_IMAGE_NONE IDENT:) URI:LIST_STYLE_IMAGE_URI
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_list_style_image(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	(match token.token_type { CSS_TOKEN_URI => false, _ => true}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_LIST_STYLE_IMAGE)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_LIST_STYLE_IMAGE, 0,LIST_STYLE_IMAGE_NONE)
	} 
	else  if match token.token_type { CSS_TOKEN_URI => true, _ => false} {

		match (*sheet.resolve)(copy sheet.url, token.idata.get_ref().clone()) {
			(CSS_OK, Some(uri)) => {
				let uri_snumber = sheet.css__stylesheet_string_add(lwc_string_data(uri));
				css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_LIST_STYLE_IMAGE, 0, LIST_STYLE_IMAGE_URI );
				css_stylesheet::css__stylesheet_style_append(result, uri_snumber as u32)

			},
			(error, _ ) => {
				*ctx = orig_ctx;
				return error
			},
		}

	} 
	 else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     list_style_position:CSS_PROP_LIST_STYLE_POSITION IDENT:( INHERIT: INSIDE:0,LIST_STYLE_POSITION_INSIDE OUTSIDE:0,LIST_STYLE_POSITION_OUTSIDE IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_list_style_position(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_LIST_STYLE_POSITION)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INSIDE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_LIST_STYLE_POSITION, 0,LIST_STYLE_POSITION_INSIDE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), OUTSIDE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_LIST_STYLE_POSITION, 0,LIST_STYLE_POSITION_OUTSIDE)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     orphans:CSS_PROP_ORPHANS IDENT:INHERIT NUMBER:( true:ORPHANS_SET RANGE:num<0 NUMBER:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_orphans(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	(match token.token_type { CSS_TOKEN_NUMBER => false, _ => true})  {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_ORPHANS)
	} 
	else 	if match token.token_type { CSS_TOKEN_NUMBER => true, _ => false} {
		let mut (num,consumed): (i32,uint)=  css__number_from_lwc_string(token.idata.get_ref().clone(), true);
		/* Invalid if there are trailing characters */
		if consumed != lwc_string_length(token.idata.get_ref().clone()) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_ORPHANS, 0, ORPHANS_SET);
		css_stylesheet::css__stylesheet_style_append(result, num as u32)
	} 
	 else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     outline_color:CSS_PROP_OUTLINE_COLOR IDENT:( INHERIT: INVERT:0,OUTLINE_COLOR_INVERT IDENT:) COLOR:OUTLINE_COLOR_SET
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_outline_color(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_OUTLINE_COLOR)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INVERT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_COLOR, 0,OUTLINE_COLOR_INVERT)
	} 
	else 	{
		*ctx = orig_ctx;

		let mut value:u16;

		let mut color:u32;

		let (value_option, color_option, res)= css__parse_color_specifier(sheet, strings, vector, ctx);
		match res {
			CSS_OK => {
				value = value_option.unwrap();
				color = color_option.unwrap() },
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_COLOR, 0, value);

		if value == COLOR_SET {
			css_stylesheet::css__stylesheet_style_append(result, color as u32)
		}
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     outline_style:CSS_PROP_OUTLINE_STYLE IDENT:( INHERIT: NONE:0,BORDER_STYLE_NONE DOTTED:0,BORDER_STYLE_DOTTED DASHED:0,BORDER_STYLE_DASHED SOLID:0,BORDER_STYLE_SOLID LIBCSS_DOUBLE:0,BORDER_STYLE_DOUBLE GROOVE:0,BORDER_STYLE_GROOVE RIDGE:0,BORDER_STYLE_RIDGE INSET:0,BORDER_STYLE_INSET OUTSET:0,BORDER_STYLE_OUTSET IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_outline_style(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_OUTLINE_STYLE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0,BORDER_STYLE_NONE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), DOTTED as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0,BORDER_STYLE_DOTTED)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), DASHED as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0,BORDER_STYLE_DASHED)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SOLID as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0,BORDER_STYLE_SOLID)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LIBCSS_DOUBLE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0,BORDER_STYLE_DOUBLE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), GROOVE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0,BORDER_STYLE_GROOVE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RIDGE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0,BORDER_STYLE_RIDGE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INSET as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0,BORDER_STYLE_INSET)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), OUTSET as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_OUTLINE_STYLE, 0,BORDER_STYLE_OUTSET)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     outline_width:CSS_PROP_OUTLINE_WIDTH WRAP:css__parse_border_side_width
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_outline_width(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side_width(sheet, strings, vector, ctx, result, CSS_PROP_OUTLINE_WIDTH)
}
/**
 * #Generated from:
 *
 *     overflow:CSS_PROP_OVERFLOW IDENT:( INHERIT: VISIBLE:0,OVERFLOW_VISIBLE HIDDEN:0,OVERFLOW_HIDDEN SCROLL:0,OVERFLOW_SCROLL AUTO:0,OVERFLOW_AUTO  IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_overflow(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_OVERFLOW)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), VISIBLE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_OVERFLOW, 0,OVERFLOW_VISIBLE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), HIDDEN as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_OVERFLOW, 0,OVERFLOW_HIDDEN)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SCROLL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_OVERFLOW, 0,OVERFLOW_SCROLL)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_OVERFLOW, 0,OVERFLOW_AUTO)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     page_break_after:CSS_PROP_PAGE_BREAK_AFTER IDENT:( INHERIT: AUTO:0,PAGE_BREAK_AFTER_AUTO ALWAYS:0,PAGE_BREAK_AFTER_ALWAYS AVOID:0,PAGE_BREAK_AFTER_AVOID LEFT:0,PAGE_BREAK_AFTER_LEFT RIGHT:0,PAGE_BREAK_AFTER_RIGHT IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_page_break_after(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_PAGE_BREAK_AFTER)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_AFTER, 0,PAGE_BREAK_AFTER_AUTO)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), ALWAYS as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_AFTER, 0,PAGE_BREAK_AFTER_ALWAYS)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AVOID as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_AFTER, 0,PAGE_BREAK_AFTER_AVOID)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LEFT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_AFTER, 0,PAGE_BREAK_AFTER_LEFT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RIGHT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_AFTER, 0,PAGE_BREAK_AFTER_RIGHT)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     page_break_before:CSS_PROP_PAGE_BREAK_BEFORE IDENT:( INHERIT: AUTO:0,PAGE_BREAK_BEFORE_AUTO ALWAYS:0,PAGE_BREAK_BEFORE_ALWAYS AVOID:0,PAGE_BREAK_BEFORE_AVOID LEFT:0,PAGE_BREAK_BEFORE_LEFT RIGHT:0,PAGE_BREAK_BEFORE_RIGHT IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_page_break_before(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_PAGE_BREAK_BEFORE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_BEFORE, 0,PAGE_BREAK_BEFORE_AUTO)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), ALWAYS as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_BEFORE, 0,PAGE_BREAK_BEFORE_ALWAYS)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AVOID as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_BEFORE, 0,PAGE_BREAK_BEFORE_AVOID)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LEFT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_BEFORE, 0,PAGE_BREAK_BEFORE_LEFT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RIGHT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_BEFORE, 0,PAGE_BREAK_BEFORE_RIGHT)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     page_break_inside:CSS_PROP_PAGE_BREAK_INSIDE IDENT:( INHERIT: AUTO:0,PAGE_BREAK_INSIDE_AUTO AVOID:0,PAGE_BREAK_INSIDE_AVOID IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_page_break_inside(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_PAGE_BREAK_INSIDE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_INSIDE, 0,PAGE_BREAK_INSIDE_AUTO)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AVOID as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PAGE_BREAK_INSIDE, 0,PAGE_BREAK_INSIDE_AVOID)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     pause_after:CSS_PROP_PAUSE_AFTER IDENT:INHERIT LENGTH_UNIT:( UNIT_S:PAUSE_AFTER_SET DISALLOW:(unit&UNIT_TIME)==0&&(unit&UNIT_PCT)==0 RANGE:<0 LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_pause_after(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_PAUSE_AFTER)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_S as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		if (unit&UNIT_TIME)==0&&(unit&UNIT_PCT)==0 {
			*ctx = orig_ctx;
			return CSS_INVALID
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PAUSE_AFTER, 0, PAUSE_AFTER_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     pause_before:CSS_PROP_PAUSE_BEFORE IDENT:INHERIT LENGTH_UNIT:( UNIT_S:PAUSE_BEFORE_SET DISALLOW:(unit&UNIT_TIME)==0&&(unit&UNIT_PCT)==0 RANGE:<0 LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_pause_before(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_PAUSE_BEFORE)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_S as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		if (unit&UNIT_TIME)==0&&(unit&UNIT_PCT)==0 {
			*ctx = orig_ctx;
			return CSS_INVALID
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PAUSE_BEFORE, 0, PAUSE_BEFORE_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     pitch:CSS_PROP_PITCH IDENT:( INHERIT: X_LOW:0,PITCH_X_LOW LOW:0,PITCH_LOW MEDIUM:0,PITCH_MEDIUM HIGH:0,PITCH_HIGH X_HIGH:0,PITCH_X_HIGH IDENT:) LENGTH_UNIT:( UNIT_HZ:PITCH_FREQUENCY ALLOW:unit&UNIT_FREQ!=0 RANGE:<0 LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_pitch(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_PITCH)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), X_LOW as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PITCH, 0,PITCH_X_LOW)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LOW as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PITCH, 0,PITCH_LOW)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), MEDIUM as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PITCH, 0,PITCH_MEDIUM)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), HIGH as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PITCH, 0,PITCH_HIGH)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), X_HIGH as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PITCH, 0,PITCH_X_HIGH)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_HZ as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		if !(unit&UNIT_FREQ!=0) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PITCH, 0, PITCH_FREQUENCY);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     pitch_range:CSS_PROP_PITCH_RANGE IDENT:INHERIT NUMBER:( false:PITCH_RANGE_SET RANGE:num<0||num>F_100 NUMBER:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_pitch_range(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	(match token.token_type { CSS_TOKEN_NUMBER => false, _ => true})  {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_PITCH_RANGE)
	} 
	else 	if match token.token_type { CSS_TOKEN_NUMBER => true, _ => false} {
		let mut (num,consumed): (i32,uint)=  css__number_from_lwc_string(token.idata.get_ref().clone(), false);
		/* Invalid if there are trailing characters */
		if consumed != lwc_string_length(token.idata.get_ref().clone()) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_PITCH_RANGE, 0, PITCH_RANGE_SET);
		css_stylesheet::css__stylesheet_style_append(result, num as u32)
	} 
	 else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     position:CSS_PROP_POSITION IDENT:( INHERIT: LIBCSS_STATIC:0,POSITION_STATIC RELATIVE:0,POSITION_RELATIVE ABSOLUTE:0,POSITION_ABSOLUTE FIXED:0,POSITION_FIXED IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_position(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_POSITION)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LIBCSS_STATIC as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_POSITION, 0,POSITION_STATIC)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RELATIVE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_POSITION, 0,POSITION_RELATIVE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), ABSOLUTE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_POSITION, 0,POSITION_ABSOLUTE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), FIXED as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_POSITION, 0,POSITION_FIXED)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     richness:CSS_PROP_RICHNESS IDENT:INHERIT NUMBER:( false:RICHNESS_SET RANGE:num<0||num>F_100 NUMBER:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_richness(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	(match token.token_type { CSS_TOKEN_NUMBER => false, _ => true})  {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_RICHNESS)
	} 
	else 	if match token.token_type { CSS_TOKEN_NUMBER => true, _ => false} {
		let mut (num,consumed): (i32,uint)=  css__number_from_lwc_string(token.idata.get_ref().clone(), false);
		/* Invalid if there are trailing characters */
		if consumed != lwc_string_length(token.idata.get_ref().clone()) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_RICHNESS, 0, RICHNESS_SET);
		css_stylesheet::css__stylesheet_style_append(result, num as u32)
	} 
	 else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     speak:CSS_PROP_SPEAK IDENT:( INHERIT: NORMAL:0,SPEAK_NORMAL NONE:0,SPEAK_NONE SPELL_OUT:0,SPEAK_SPELL_OUT IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_speak(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_SPEAK)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NORMAL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK, 0,SPEAK_NORMAL)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK, 0,SPEAK_NONE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SPELL_OUT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK, 0,SPEAK_SPELL_OUT)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     speak_header:CSS_PROP_SPEAK_HEADER IDENT:( INHERIT: ONCE:0,SPEAK_HEADER_ONCE ALWAYS:0,SPEAK_HEADER_ALWAYS IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_speak_header(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_SPEAK_HEADER)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), ONCE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK_HEADER, 0,SPEAK_HEADER_ONCE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), ALWAYS as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK_HEADER, 0,SPEAK_HEADER_ALWAYS)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     speak_numeral:CSS_PROP_SPEAK_NUMERAL IDENT:( INHERIT: DIGITS:0,SPEAK_NUMERAL_DIGITS CONTINUOUS:0,SPEAK_NUMERAL_CONTINUOUS IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_speak_numeral(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_SPEAK_NUMERAL)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), DIGITS as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK_NUMERAL, 0,SPEAK_NUMERAL_DIGITS)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), CONTINUOUS as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK_NUMERAL, 0,SPEAK_NUMERAL_CONTINUOUS)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     speak_punctuation:CSS_PROP_SPEAK_PUNCTUATION IDENT:( INHERIT: CODE:0,SPEAK_PUNCTUATION_CODE NONE:0,SPEAK_PUNCTUATION_NONE IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_speak_punctuation(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_SPEAK_PUNCTUATION)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), CODE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK_PUNCTUATION, 0,SPEAK_PUNCTUATION_CODE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEAK_PUNCTUATION, 0,SPEAK_PUNCTUATION_NONE)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     speech_rate:CSS_PROP_SPEECH_RATE IDENT:( INHERIT: X_SLOW:0,SPEECH_RATE_X_SLOW SLOW:0,SPEECH_RATE_SLOW MEDIUM:0,SPEECH_RATE_MEDIUM FAST:0,SPEECH_RATE_FAST X_FAST:0,SPEECH_RATE_X_FAST FASTER:0,SPEECH_RATE_FASTER SLOWER:0,SPEECH_RATE_SLOWER IDENT:) NUMBER:( false:SPEECH_RATE_SET RANGE:num<0 NUMBER:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_speech_rate(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	(match token.token_type { CSS_TOKEN_NUMBER => false, _ => true})  {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_SPEECH_RATE)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), X_SLOW as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEECH_RATE, 0,SPEECH_RATE_X_SLOW)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SLOW as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEECH_RATE, 0,SPEECH_RATE_SLOW)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), MEDIUM as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEECH_RATE, 0,SPEECH_RATE_MEDIUM)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), FAST as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEECH_RATE, 0,SPEECH_RATE_FAST)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), X_FAST as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEECH_RATE, 0,SPEECH_RATE_X_FAST)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), FASTER as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEECH_RATE, 0,SPEECH_RATE_FASTER)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SLOWER as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEECH_RATE, 0,SPEECH_RATE_SLOWER)
	} 
	else 	if match token.token_type { CSS_TOKEN_NUMBER => true, _ => false} {
		let mut (num,consumed): (i32,uint)=  css__number_from_lwc_string(token.idata.get_ref().clone(), false);
		/* Invalid if there are trailing characters */
		if consumed != lwc_string_length(token.idata.get_ref().clone()) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_SPEECH_RATE, 0, SPEECH_RATE_SET);
		css_stylesheet::css__stylesheet_style_append(result, num as u32)
	} 
	 else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     stress:CSS_PROP_STRESS IDENT:INHERIT NUMBER:( false:STRESS_SET RANGE:num<0||num>INTTOFIX(100) NUMBER:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_stress(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	(match token.token_type { CSS_TOKEN_NUMBER => false, _ => true})  {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_STRESS)
	} 
	else 	if match token.token_type { CSS_TOKEN_NUMBER => true, _ => false} {
		let mut (num,consumed): (i32,uint)=  css__number_from_lwc_string(token.idata.get_ref().clone(), false);
		/* Invalid if there are trailing characters */
		if consumed != lwc_string_length(token.idata.get_ref().clone()) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_STRESS, 0, STRESS_SET);
		css_stylesheet::css__stylesheet_style_append(result, num as u32)
	} 
	 else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     table_layout:CSS_PROP_TABLE_LAYOUT IDENT:( INHERIT: AUTO:0,TABLE_LAYOUT_AUTO FIXED:0,TABLE_LAYOUT_FIXED IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_table_layout(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_TABLE_LAYOUT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_TABLE_LAYOUT, 0,TABLE_LAYOUT_AUTO)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), FIXED as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_TABLE_LAYOUT, 0,TABLE_LAYOUT_FIXED)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     text_align:CSS_PROP_TEXT_ALIGN IDENT:( INHERIT: LEFT:0,TEXT_ALIGN_LEFT RIGHT:0,TEXT_ALIGN_RIGHT CENTER:0,TEXT_ALIGN_CENTER JUSTIFY:0,TEXT_ALIGN_JUSTIFY LIBCSS_LEFT:0,TEXT_ALIGN_LIBCSS_LEFT LIBCSS_CENTER:0,TEXT_ALIGN_LIBCSS_CENTER LIBCSS_RIGHT:0,TEXT_ALIGN_LIBCSS_RIGHT IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_text_align(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_TEXT_ALIGN)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LEFT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_ALIGN, 0,TEXT_ALIGN_LEFT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RIGHT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_ALIGN, 0,TEXT_ALIGN_RIGHT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), CENTER as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_ALIGN, 0,TEXT_ALIGN_CENTER)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), JUSTIFY as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_ALIGN, 0,TEXT_ALIGN_JUSTIFY)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LIBCSS_LEFT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_ALIGN, 0,TEXT_ALIGN_LIBCSS_LEFT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LIBCSS_CENTER as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_ALIGN, 0,TEXT_ALIGN_LIBCSS_CENTER)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LIBCSS_RIGHT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_ALIGN, 0,TEXT_ALIGN_LIBCSS_RIGHT)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     text_indent:CSS_PROP_TEXT_INDENT IDENT:INHERIT LENGTH_UNIT:( UNIT_PX:TEXT_INDENT_SET DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_text_indent(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_TEXT_INDENT)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_INDENT, 0, TEXT_INDENT_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     text_transform:CSS_PROP_TEXT_TRANSFORM IDENT:( INHERIT: CAPITALIZE:0,TEXT_TRANSFORM_CAPITALIZE UPPERCASE:0,TEXT_TRANSFORM_UPPERCASE LOWERCASE:0,TEXT_TRANSFORM_LOWERCASE NONE:0,TEXT_TRANSFORM_NONE IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_text_transform(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_TEXT_TRANSFORM)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), CAPITALIZE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_TRANSFORM, 0,TEXT_TRANSFORM_CAPITALIZE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), UPPERCASE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_TRANSFORM, 0,TEXT_TRANSFORM_UPPERCASE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LOWERCASE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_TRANSFORM, 0,TEXT_TRANSFORM_LOWERCASE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_TEXT_TRANSFORM, 0,TEXT_TRANSFORM_NONE)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     unicode_bidi:CSS_PROP_UNICODE_BIDI IDENT:( INHERIT: NORMAL:0,UNICODE_BIDI_NORMAL EMBED:0,UNICODE_BIDI_EMBED BIDI_OVERRIDE:0,UNICODE_BIDI_BIDI_OVERRIDE IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_unicode_bidi(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_UNICODE_BIDI)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NORMAL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_UNICODE_BIDI, 0,UNICODE_BIDI_NORMAL)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), EMBED as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_UNICODE_BIDI, 0,UNICODE_BIDI_EMBED)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), BIDI_OVERRIDE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_UNICODE_BIDI, 0,UNICODE_BIDI_BIDI_OVERRIDE)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     vertical_align:CSS_PROP_VERTICAL_ALIGN IDENT:( INHERIT: BASELINE:0,VERTICAL_ALIGN_BASELINE SUB:0,VERTICAL_ALIGN_SUB SUPER:0,VERTICAL_ALIGN_SUPER TOP:0,VERTICAL_ALIGN_TOP TEXT_TOP:0,VERTICAL_ALIGN_TEXT_TOP MIDDLE:0,VERTICAL_ALIGN_MIDDLE BOTTOM:0,VERTICAL_ALIGN_BOTTOM TEXT_BOTTOM:0,VERTICAL_ALIGN_TEXT_BOTTOM IDENT:) LENGTH_UNIT:( UNIT_PX:VERTICAL_ALIGN_SET DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_vertical_align(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_VERTICAL_ALIGN)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), BASELINE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0,VERTICAL_ALIGN_BASELINE)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SUB as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0,VERTICAL_ALIGN_SUB)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SUPER as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0,VERTICAL_ALIGN_SUPER)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), TOP as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0,VERTICAL_ALIGN_TOP)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), TEXT_TOP as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0,VERTICAL_ALIGN_TEXT_TOP)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), MIDDLE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0,VERTICAL_ALIGN_MIDDLE)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), BOTTOM as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0,VERTICAL_ALIGN_BOTTOM)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), TEXT_BOTTOM as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0,VERTICAL_ALIGN_TEXT_BOTTOM)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VERTICAL_ALIGN, 0, VERTICAL_ALIGN_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     visibility:CSS_PROP_VISIBILITY IDENT:( INHERIT: VISIBLE:0,VISIBILITY_VISIBLE HIDDEN:0,VISIBILITY_HIDDEN COLLAPSE:0,VISIBILITY_COLLAPSE IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_visibility(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_VISIBILITY)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), VISIBLE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VISIBILITY, 0,VISIBILITY_VISIBLE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), HIDDEN as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VISIBILITY, 0,VISIBILITY_HIDDEN)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), COLLAPSE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VISIBILITY, 0,VISIBILITY_COLLAPSE)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     volume:CSS_PROP_VOLUME IDENT:( INHERIT: SILENT:0,VOLUME_SILENT X_SOFT:0,VOLUME_X_SOFT SOFT:0,VOLUME_SOFT MEDIUM:0,VOLUME_MEDIUM LOUD:0,VOLUME_LOUD X_LOUD:0,VOLUME_X_LOUD IDENT:) NUMBER:( false:VOLUME_NUMBER RANGE:num<0||num>F_100 NUMBER:) LENGTH_UNIT:( UNIT_PX:VOLUME_DIMENSION ALLOW:unit&UNIT_PCT!=0 RANGE:<0 LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_volume(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_VOLUME)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SILENT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VOLUME, 0,VOLUME_SILENT)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), X_SOFT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VOLUME, 0,VOLUME_X_SOFT)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SOFT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VOLUME, 0,VOLUME_SOFT)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), MEDIUM as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VOLUME, 0,VOLUME_MEDIUM)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LOUD as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VOLUME, 0,VOLUME_LOUD)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), X_LOUD as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VOLUME, 0,VOLUME_X_LOUD)
	} 
	else 	if match token.token_type { CSS_TOKEN_NUMBER => true, _ => false} {
		let mut (num,consumed): (i32,uint)=  css__number_from_lwc_string(token.idata.get_ref().clone(), false);
		/* Invalid if there are trailing characters */
		if consumed != lwc_string_length(token.idata.get_ref().clone()) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VOLUME, 0, VOLUME_NUMBER);
		css_stylesheet::css__stylesheet_style_append(result, num as u32)
	} 
	 else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		if !(unit&UNIT_PCT!=0) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_VOLUME, 0, VOLUME_DIMENSION);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     white_space:CSS_PROP_WHITE_SPACE IDENT:( INHERIT: NORMAL:0,WHITE_SPACE_NORMAL PRE:0,WHITE_SPACE_PRE NOWRAP:0,WHITE_SPACE_NOWRAP PRE_WRAP:0,WHITE_SPACE_PRE_WRAP PRE_LINE:0,WHITE_SPACE_PRE_LINE  IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_white_space(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_WHITE_SPACE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NORMAL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_WHITE_SPACE, 0,WHITE_SPACE_NORMAL)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), PRE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_WHITE_SPACE, 0,WHITE_SPACE_PRE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NOWRAP as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_WHITE_SPACE, 0,WHITE_SPACE_NOWRAP)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), PRE_WRAP as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_WHITE_SPACE, 0,WHITE_SPACE_PRE_WRAP)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), PRE_LINE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_WHITE_SPACE, 0,WHITE_SPACE_PRE_LINE)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     widows:CSS_PROP_WIDOWS IDENT:INHERIT NUMBER:( true:WIDOWS_SET RANGE:num<0 NUMBER:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_widows(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	(match token.token_type { CSS_TOKEN_NUMBER => false, _ => true})  {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_WIDOWS)
	} 
	else 	if match token.token_type { CSS_TOKEN_NUMBER => true, _ => false} {
		let mut (num,consumed): (i32,uint)=  css__number_from_lwc_string(token.idata.get_ref().clone(), true);
		/* Invalid if there are trailing characters */
		if consumed != lwc_string_length(token.idata.get_ref().clone()) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_WIDOWS, 0, WIDOWS_SET);
		css_stylesheet::css__stylesheet_style_append(result, num as u32)
	} 
	 else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     width:CSS_PROP_WIDTH IDENT:( INHERIT: AUTO:0,WIDTH_AUTO IDENT:) LENGTH_UNIT:( UNIT_PX:WIDTH_SET DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) RANGE:<0 LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_width(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_WIDTH)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_WIDTH, 0,WIDTH_AUTO)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		if (unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_WIDTH, 0, WIDTH_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     word_spacing:CSS_PROP_WORD_SPACING IDENT:( INHERIT: NORMAL:0,WORD_SPACING_NORMAL IDENT:) LENGTH_UNIT:( UNIT_PX:WORD_SPACING_SET DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0)||unit&UNIT_PCT LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_word_spacing(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_WORD_SPACING)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NORMAL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_WORD_SPACING, 0,WORD_SPACING_NORMAL)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_WORD_SPACING, 0, WORD_SPACING_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     z_index:CSS_PROP_Z_INDEX IDENT:( INHERIT: AUTO:0,Z_INDEX_AUTO IDENT:) NUMBER:( true:Z_INDEX_SET NUMBER:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_z_index(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	(match token.token_type { CSS_TOKEN_NUMBER => false, _ => true})  {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_Z_INDEX)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_Z_INDEX, 0,Z_INDEX_AUTO)
	} 
	else 	if match token.token_type { CSS_TOKEN_NUMBER => true, _ => false} {
		let mut (num,consumed): (i32,uint)=  css__number_from_lwc_string(token.idata.get_ref().clone(), true);
		/* Invalid if there are trailing characters */
		if consumed != lwc_string_length(token.idata.get_ref().clone()) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_Z_INDEX, 0, Z_INDEX_SET);
		css_stylesheet::css__stylesheet_style_append(result, num as u32)
	} 
	 else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     break_after:CSS_PROP_BREAK_AFTER IDENT:( INHERIT: AUTO:0,BREAK_AFTER_AUTO ALWAYS:0,BREAK_AFTER_ALWAYS AVOID:0,BREAK_AFTER_AVOID LEFT:0,BREAK_AFTER_LEFT RIGHT:0,BREAK_AFTER_RIGHT PAGE:0,BREAK_AFTER_PAGE COLUMN:0,BREAK_AFTER_COLUMN AVOID_PAGE:0,BREAK_AFTER_AVOID_PAGE AVOID_COLUMN:0,BREAK_AFTER_AVOID_COLUMN IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_break_after(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BREAK_AFTER)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0,BREAK_AFTER_AUTO)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), ALWAYS as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0,BREAK_AFTER_ALWAYS)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AVOID as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0,BREAK_AFTER_AVOID)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LEFT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0,BREAK_AFTER_LEFT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RIGHT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0,BREAK_AFTER_RIGHT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), PAGE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0,BREAK_AFTER_PAGE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), COLUMN as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0,BREAK_AFTER_COLUMN)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AVOID_PAGE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0,BREAK_AFTER_AVOID_PAGE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AVOID_COLUMN as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_AFTER, 0,BREAK_AFTER_AVOID_COLUMN)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     break_before:CSS_PROP_BREAK_BEFORE IDENT:( INHERIT: AUTO:0,BREAK_BEFORE_AUTO ALWAYS:0,BREAK_BEFORE_ALWAYS AVOID:0,BREAK_BEFORE_AVOID LEFT:0,BREAK_BEFORE_LEFT RIGHT:0,BREAK_BEFORE_RIGHT PAGE:0,BREAK_BEFORE_PAGE COLUMN:0,BREAK_BEFORE_COLUMN AVOID_PAGE:0,BREAK_BEFORE_AVOID_PAGE AVOID_COLUMN:0,BREAK_BEFORE_AVOID_COLUMN IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_break_before(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BREAK_BEFORE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0,BREAK_BEFORE_AUTO)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), ALWAYS as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0,BREAK_BEFORE_ALWAYS)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AVOID as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0,BREAK_BEFORE_AVOID)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LEFT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0,BREAK_BEFORE_LEFT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RIGHT as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0,BREAK_BEFORE_RIGHT)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), PAGE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0,BREAK_BEFORE_PAGE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), COLUMN as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0,BREAK_BEFORE_COLUMN)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AVOID_PAGE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0,BREAK_BEFORE_AVOID_PAGE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AVOID_COLUMN as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_BEFORE, 0,BREAK_BEFORE_AVOID_COLUMN)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     break_inside:CSS_PROP_BREAK_INSIDE IDENT:( INHERIT: AUTO:0,BREAK_INSIDE_AUTO AVOID:0,BREAK_INSIDE_AVOID AVOID_PAGE:0,BREAK_INSIDE_AVOID_PAGE AVOID_COLUMN:0,BREAK_INSIDE_AVOID_COLUMN IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_break_inside(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BREAK_INSIDE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_INSIDE, 0,BREAK_INSIDE_AUTO)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AVOID as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_INSIDE, 0,BREAK_INSIDE_AVOID)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AVOID_PAGE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_INSIDE, 0,BREAK_INSIDE_AVOID_PAGE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AVOID_COLUMN as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_BREAK_INSIDE, 0,BREAK_INSIDE_AVOID_COLUMN)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     column_count:CSS_PROP_COLUMN_COUNT IDENT:( INHERIT: AUTO:0,COLUMN_COUNT_AUTO IDENT:) NUMBER:( true:COLUMN_COUNT_SET RANGE:num<0 NUMBER:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_column_count(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	(match token.token_type { CSS_TOKEN_NUMBER => false, _ => true})  {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_COLUMN_COUNT)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_COUNT, 0,COLUMN_COUNT_AUTO)
	} 
	else 	if match token.token_type { CSS_TOKEN_NUMBER => true, _ => false} {
		let mut (num,consumed): (i32,uint)=  css__number_from_lwc_string(token.idata.get_ref().clone(), true);
		/* Invalid if there are trailing characters */
		if consumed != lwc_string_length(token.idata.get_ref().clone()) {
			*ctx = orig_ctx;
			return CSS_INVALID
		}
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_COUNT, 0, COLUMN_COUNT_SET);
		css_stylesheet::css__stylesheet_style_append(result, num as u32)
	} 
	 else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     column_fill:CSS_PROP_COLUMN_FILL IDENT:( INHERIT: BALANCE:0,COLUMN_FILL_BALANCE AUTO:0,COLUMN_FILL_AUTO IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_column_fill(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_COLUMN_FILL)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), BALANCE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_FILL, 0,COLUMN_FILL_BALANCE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_FILL, 0,COLUMN_FILL_AUTO)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     column_gap:CSS_PROP_COLUMN_GAP IDENT:( INHERIT: NORMAL:0,COLUMN_GAP_NORMAL IDENT:) LENGTH_UNIT:( UNIT_PX:COLUMN_GAP_SET RANGE:<0 DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0)||unit&UNIT_PCT LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_column_gap(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_COLUMN_GAP)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NORMAL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_GAP, 0,COLUMN_GAP_NORMAL)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		if length <0 {
			*ctx = orig_ctx;
			return CSS_INVALID
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_GAP, 0, COLUMN_GAP_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     column_rule_color:CSS_PROP_COLUMN_RULE_COLOR IDENT:( INHERIT: IDENT:) COLOR:COLUMN_RULE_COLOR_SET
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_column_rule_color(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_COLUMN_RULE_COLOR)
	} 
	else 	{
		*ctx = orig_ctx;

		let mut value:u16;

		let mut color:u32;

		let (value_option, color_option, res)= css__parse_color_specifier(sheet, strings, vector, ctx);
		match res {
			CSS_OK => {
				value = value_option.unwrap();
				color = color_option.unwrap() },
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_COLOR, 0, value);

		if value == COLOR_SET {
			css_stylesheet::css__stylesheet_style_append(result, color as u32)
		}
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     column_rule_style:CSS_PROP_COLUMN_RULE_STYLE IDENT:( INHERIT: NONE:0,BORDER_STYLE_NONE HIDDEN:0,BORDER_STYLE_HIDDEN DOTTED:0,BORDER_STYLE_DOTTED DASHED:0,BORDER_STYLE_DASHED SOLID:0,BORDER_STYLE_SOLID LIBCSS_DOUBLE:0,BORDER_STYLE_DOUBLE GROOVE:0,BORDER_STYLE_GROOVE RIDGE:0,BORDER_STYLE_RIDGE INSET:0,BORDER_STYLE_INSET OUTSET:0,BORDER_STYLE_OUTSET IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_column_rule_style(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_COLUMN_RULE_STYLE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0,BORDER_STYLE_NONE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), HIDDEN as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0,BORDER_STYLE_HIDDEN)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), DOTTED as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0,BORDER_STYLE_DOTTED)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), DASHED as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0,BORDER_STYLE_DASHED)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), SOLID as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0,BORDER_STYLE_SOLID)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), LIBCSS_DOUBLE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0,BORDER_STYLE_DOUBLE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), GROOVE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0,BORDER_STYLE_GROOVE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), RIDGE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0,BORDER_STYLE_RIDGE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INSET as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0,BORDER_STYLE_INSET)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), OUTSET as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_RULE_STYLE, 0,BORDER_STYLE_OUTSET)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     column_rule_width:CSS_PROP_COLUMN_RULE_WIDTH WRAP:css__parse_border_side_width
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_column_rule_width(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side_width(sheet, strings, vector, ctx, result, CSS_PROP_COLUMN_RULE_WIDTH)
}
/**
 * #Generated from:
 *
 *     column_span:CSS_PROP_COLUMN_SPAN IDENT:( INHERIT: NONE:0,COLUMN_SPAN_NONE ALL:0,COLUMN_SPAN_ALL IDENT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_column_span(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) {
		*ctx = orig_ctx;
		return CSS_INVALID
	}

	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_COLUMN_SPAN)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), NONE as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_SPAN, 0,COLUMN_SPAN_NONE)
	} 
	else 	if 	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), ALL as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_SPAN, 0,COLUMN_SPAN_ALL)
	} 
	else {
		error = CSS_INVALID }

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

/**
 * #Generated from:
 *
 *     column_width:CSS_PROP_COLUMN_WIDTH IDENT:( INHERIT: AUTO:0,COLUMN_WIDTH_AUTO IDENT:) LENGTH_UNIT:( UNIT_PX:COLUMN_WIDTH_SET DISALLOW:(unit&UNIT_ANGLE!=0)||(unit&UNIT_TIME!=0)||(unit&UNIT_FREQ!=0)||unit&UNIT_PCT LENGTH_UNIT:)
 * 
 */

/**
* #Arguments:
*  'sheet' -  Stylesheet.
*  'strings' -  css_propstrings.
*  'vector' -  Vector of tokens to process.
*  'ctx' -  Pointer to vector iteration context.
*  'result' - resulting style.
* #Return Value:
*  'css_error' - CSS_OK on success,
      CSS_INVALID if the input is not valid
* #Post Condition:
*   ctx is updated with the next token to process
*     If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_column_width(sheet:@mut css_stylesheet, strings:&mut ~css_propstrings,
      vector:&~[@css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
	let orig_ctx = *ctx;
	let mut error:css_error=CSS_OK;
	let mut token:&@css_token;

	if *ctx >= vector.len() {
		return CSS_INVALID
	}
	token = &vector[*ctx];
	*ctx += 1;

	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), INHERIT as uint) {
		css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_COLUMN_WIDTH)
	} 
	else 	if (match token.token_type { CSS_TOKEN_IDENT => true, _ => false}) && 
	strings.lwc_string_caseless_isequal(token.idata.get_ref().clone(), AUTO as uint) {
		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_WIDTH, 0,COLUMN_WIDTH_AUTO)
	} 
	else 	{
		let length:u32;
		*ctx = orig_ctx;

		let mut unit:u32;

		let (length_option, unit_option, res) =css__parse_unit_specifier(sheet, vector, ctx, UNIT_PX as u32);
		match res {
			CSS_OK => {
				unit = unit_option.unwrap();
				length = length_option.unwrap() as u32;
			},
			_ => {
				*ctx = orig_ctx;
				return error
			}
		}

		css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_COLUMN_WIDTH, 0, COLUMN_WIDTH_SET);

		css_stylesheet::css__stylesheet_style_vappend(result , [length, unit])
	}

	if match error {CSS_OK => false, _ => true} {
		*ctx = orig_ctx;
	}
 
	return error
}

