use wapcaplet::*;

use bytecode::bytecode::*;
use bytecode::opcodes::*;

use include::fpmath::*;
use include::properties::*;

use lex::lexer::*;
use stylesheet::*;

use parse::propstrings::*;
use parse::properties::autogenerated::*;
use parse::properties::common::*;

use utils::errors::*;
use std::cast::*;

pub type handle =  @extern fn(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style) ->css_error;
pub type reserved_fn = @extern fn (strings:&css_propstrings, lwc_ref:&mut ~lwc, ident: &css_token) -> bool;
pub type get_value_fn = @extern fn (strings: &css_propstrings , lwc_ref:&mut ~lwc, token: &css_token , first: bool) -> u32;

pub struct css_properties {
    property_handlers: ~[handle],
    sheet: @mut css_stylesheet
}

impl css_properties {

    pub fn css_properties(sheet_instance: @mut css_stylesheet) -> ~css_properties {
        /*
         * Dispatch table of property handlers, indexed by property enum
         */
        let vec = ~[
            @css_properties::css__parse_azimuth , //0
            @css_properties::css__parse_background , //1
            @css__parse_background_attachment, //2
            @css__parse_background_color, //3
            @css__parse_background_image, //4
            @css_properties::css__parse_background_position, //5
            @css__parse_background_repeat, //6
            @css_properties::css__parse_border, //7
            @css__parse_border_bottom, //8
            @css__parse_border_bottom_color, //9 
            @css__parse_border_bottom_style, //10
            @css__parse_border_bottom_width, //11
            @css__parse_border_collapse, //12
            @css_properties::css__parse_border_color, //13
            @css__parse_border_left, //14
            @css__parse_border_left_color, //15
            @css__parse_border_left_style, //16
            @css__parse_border_left_width, //17
            @css__parse_border_right, //18
            @css__parse_border_right_color, //19
            @css__parse_border_right_style, //20
            @css__parse_border_right_width, //21        
            @css_properties::css__parse_border_spacing, //22
            @css_properties::css__parse_border_style, //23
            @css__parse_border_top, //24
            @css__parse_border_top_color, //25
            @css__parse_border_top_style, //26
            @css__parse_border_top_width, //27
            @css_properties::css__parse_border_width, //28
            @css__parse_bottom, //29
            @css__parse_break_after, //30
            @css__parse_break_before, //31
            @css__parse_break_inside, //32
            @css__parse_caption_side, //33
            @css__parse_clear, //34
            @css_properties::css__parse_clip, //35
            @css__parse_color, //36
            @css_properties::css__parse_columns, //37
            @css__parse_column_count, //38
            @css__parse_column_fill, //39
            @css__parse_column_gap, //40
            @css_properties::css__parse_column_rule, //41
            @css__parse_column_rule_color, //42
            @css__parse_column_rule_style, //43
            @css__parse_column_rule_width, //44
            @css__parse_column_span, //45
            @css__parse_column_width, //46
            @css_properties::css__parse_content, //47
            @css__parse_counter_increment, //48
            @css__parse_counter_reset, //49
            @css_properties::css__parse_cue, //50
            @css__parse_cue_after, //51
            @css__parse_cue_before, //52
            @css_properties::css__parse_cursor, //53
            @css__parse_direction, //54
            @css__parse_display, //55
            @css_properties::css__parse_elevation, //56
            @css__parse_empty_cells, //57
            @css__parse_float, //58
            @css_properties::css__parse_font, //59
            @css_properties::css__parse_font_family, //60
            @css__parse_font_size, //61
            @css__parse_font_style, //62
            @css__parse_font_variant, //63
            @css_properties::css__parse_font_weight, //64
            @css__parse_height, //65
            @css__parse_left, //66
            @css__parse_letter_spacing, //67
            @css__parse_line_height, //68
            @css_properties::css__parse_list_style, //69
            @css__parse_list_style_image, //70
            @css__parse_list_style_position, //71
            @css_properties::css__parse_list_style_type, //72
            @css_properties::css__parse_margin, //73
            @css__parse_margin_bottom, //74
            @css__parse_margin_left, //75
            @css__parse_margin_right, //76
            @css__parse_margin_top, //77
            @css__parse_max_height, //78
            @css__parse_max_width, //79
            @css__parse_min_height, //80
            @css__parse_min_width, //81
            @css_properties::css__parse_opacity, //82
            @css__parse_orphans, //83
            @css_properties::css__parse_outline, //84
            @css__parse_outline_color, //85
            @css__parse_outline_style, //86
            @css__parse_outline_width, //87
            @css__parse_overflow, //88
            @css_properties::css__parse_padding, //89
            @css__parse_padding_bottom, //90
            @css__parse_padding_left, //91
            @css__parse_padding_right, //92
            @css__parse_padding_top, //93
            @css__parse_page_break_after, //94
            @css__parse_page_break_before, //95
            @css__parse_page_break_inside, //96
            @css_properties::css__parse_pause, //97
            @css__parse_pause_after, //98
            @css__parse_pause_before, //99
            @css__parse_pitch_range, //100
            @css__parse_pitch, //101
            @css_properties::css__parse_play_during, //102
            @css__parse_position, //103
            @css_properties::css__parse_quotes, //104
            @css__parse_richness, //105
            @css__parse_right, //106
            @css__parse_speak_header, //107
            @css__parse_speak_numeral, //108
            @css__parse_speak_punctuation, //109
            @css__parse_speak, //110
            @css__parse_speech_rate, //111
            @css__parse_stress, //112
            @css__parse_table_layout, //113
            @css__parse_text_align, //114
            @css_properties::css__parse_text_decoration, //115
            @css__parse_text_indent, //116
            @css__parse_text_transform, //117
            @css__parse_top, //118
            @css__parse_unicode_bidi, //119
            @css__parse_vertical_align, //120
            @css__parse_visibility, //121
            @css_properties::css__parse_voice_family, //122
            @css__parse_volume, //123
            @css__parse_white_space, //124
            @css__parse_widows, //125
            @css__parse_width, //126
            @css__parse_word_spacing, //127
            @css__parse_z_index, //128
        ];
        
        ~css_properties{
            property_handlers: vec,
            sheet: sheet_instance
        }
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' - 

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.
    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_azimuth(sheet: @mut css_stylesheet, lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        //debug!("Entering: css__parse_azimuth");
        let orig_ctx:uint = *ctx;
        let mut flags:u8 = 0;
        let mut value:u16 = 0;
        // let unit:u32 = 0;
        let mut return_length_val = None;
        let mut return_unit_val = None;

        /* angle | [ IDENT(left-side, far-left, left, center-left, center, 
         *         center-right, right, far-right, right-side) || 
         *     IDENT(behind) 
         *   ] 
         *   | IDENT(leftwards, rightwards, inherit)
         */

        if *ctx >= vector.len() {
            //debug!("Exiting: css__parse_azimuth (1)");
            return CSS_INVALID;
        }
        
        let mut token=&vector[*ctx];

        if (token.token_type as int == CSS_TOKEN_IDENT as int 
            && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), INHERIT as uint)) {
            *ctx += 1;
            flags = FLAG_INHERIT as u8 ;
        }
        else if (token.token_type as int == CSS_TOKEN_IDENT as int 
            && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), LEFTWARDS as uint)) {
            *ctx += 1;
            value = AZIMUTH_LEFTWARDS ;
        }        
        else if (token.token_type as int == CSS_TOKEN_IDENT as int 
            && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), RIGHTWARDS as uint)) {
            *ctx += 1;
            value = AZIMUTH_RIGHTWARDS ;
        }
        else if (token.token_type as int == CSS_TOKEN_IDENT as int) {
            //debug!("Entering: css__parse_azimuth:: token.token_type as int == CSS_TOKEN_IDENT as int ");

            *ctx += 1;
            /* Now, we may have one of the other keywords or behind,
             * potentially followed by behind or other keyword, 
             * respectively */

            if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), LEFT_SIDE as uint) {
                value = AZIMUTH_LEFT_SIDE ;
            }
            else if (strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), FAR_LEFT as uint)) {
                value = AZIMUTH_FAR_LEFT ;
            }
            else if (strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), LEFT as uint)) {
                value = AZIMUTH_LEFT ;
            }
            else if (strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), CENTER_LEFT as uint)) {
                value = AZIMUTH_CENTER_LEFT ;
            }
            else if (strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), CENTER as uint)) {
                value = AZIMUTH_CENTER;
            }
            else if (strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(),CENTER_RIGHT as uint)) {
                value = AZIMUTH_CENTER_RIGHT;
            }
            else if (strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), RIGHT as uint)) {
                value = AZIMUTH_RIGHT;
            }
            else if (strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), FAR_RIGHT as uint)) {
                value = AZIMUTH_FAR_RIGHT;
            }
            else if (strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), RIGHT_SIDE as uint)) {
                value = AZIMUTH_RIGHT_SIDE;
            }
            else if (strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), BEHIND as uint)) {
                //debug!("Entering: css__parse_azimuth :: BEHIND ");
                value = AZIMUTH_BEHIND;
            }
            else {
                *ctx = orig_ctx;
                //debug!("Exiting: css__parse_azimuth (2)");
                return CSS_INVALID;
            }
            
            //debug!(fmt!("css__parse_azimuth:: ctx (1) == %?", *ctx));
            consumeWhitespace(vector, ctx);
            //debug!(fmt!("css__parse_azimuth:: ctx (2) == %?", *ctx));
            /* Get potential following token */
            /* parserutils_vector_peek(vector, *ctx); */
            let mut token_null = false;
            
            //debug!(fmt!("css__parse_azimuth:: ctx (3) == %?", *ctx));
            if *ctx >= vector.len() {
                //debug!("Entering: css__parse_azimuth:: token_null = true");
                token_null = true;
            }
            else {
                token=&vector[*ctx];
                //debug!(fmt!("css__parse_azimuth:: token == %?", token));
            }

            if (!token_null && token.token_type as int == CSS_TOKEN_IDENT as int && value == AZIMUTH_BEHIND) {
                /* parserutils_vector_iterate(vector, ctx); */
                *ctx += 1;
                //debug!("Entering: css__parse_azimuth:: !token_null && token.token_type as int == CSS_TOKEN_IDENT as int && value == AZIMUTH_BEHIND");
                
                if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), LEFT_SIDE as uint) {
                    //debug!("Entering: css__parse_azimuth:: LEFT_SIDE");
                    value |= AZIMUTH_LEFT_SIDE;
                }
                else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), FAR_LEFT as uint) {
                    //debug!("Entering: css__parse_azimuth:: FAR_LEFT");
                    value |= AZIMUTH_FAR_LEFT;
                }
                else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), LEFT as uint) {
                    //debug!("Entering: css__parse_azimuth:: LEFT");
                    value |= AZIMUTH_LEFT;
                }
                else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), CENTER_LEFT as uint) {
                    //debug!("Entering: css__parse_azimuth:: CENTER_LEFT");
                    value |= AZIMUTH_CENTER_LEFT;
                }
                else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), CENTER as uint) {
                    //debug!("Entering: css__parse_azimuth:: CENTER");
                    value |=  AZIMUTH_CENTER;
                }
                else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), CENTER_RIGHT as uint) {
                    //debug!("Entering: css__parse_azimuth:: CENTER_RIGHT");
                    value |= AZIMUTH_CENTER_RIGHT;
                }
                else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), RIGHT as uint) {
                    //debug!("Entering: css__parse_azimuth:: RIGHT");
                    value |= AZIMUTH_RIGHT;
                }
                else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), FAR_RIGHT as uint) {
                    //debug!("Entering: css__parse_azimuth:: FAR_RIGHT");
                    value |= AZIMUTH_FAR_RIGHT;
                }
                else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), RIGHT_SIDE as uint) {
                    //debug!("Entering: css__parse_azimuth:: RIGHT_SIDE");
                    value |= AZIMUTH_RIGHT_SIDE;
                }
                else {
                    *ctx = orig_ctx;
                    //debug!("Exiting: css__parse_azimuth (3)");
                    return CSS_INVALID;
                }
            }
            else if  (!token_null && token.token_type as int == CSS_TOKEN_IDENT as int && value != AZIMUTH_BEHIND) {

                *ctx += 1;
                
                if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), BEHIND as uint) {
                    value |= AZIMUTH_BEHIND;
                }
                else {
                    *ctx = orig_ctx;
                    //debug!("Exiting: css__parse_azimuth (4)");
                    return CSS_INVALID;
                }
            } 
            else if ((token_null || token.token_type as int != CSS_TOKEN_IDENT as int) && value == AZIMUTH_BEHIND) {
                //debug!("Entering: css__parse_azimuth:: (token_null || token.token_type as int != CSS_TOKEN_IDENT as int) && value == AZIMUTH_BEHIND");
                value |= AZIMUTH_CENTER;
            }
        } 
        else {
            let (length_val , unit_val , result) = css__parse_unit_specifier(sheet, lwc_ref, vector, ctx, UNIT_DEG as u32);
            return_length_val = length_val;
            return_unit_val = unit_val;
            match result {
                CSS_OK => {},
                _ => {
                    *ctx = orig_ctx;
                    //debug!("Exiting: css__parse_azimuth (5)");
                    return result;
                }
            }
            if (unit_val.unwrap() & UNIT_ANGLE as u32) == 0 {
                *ctx = orig_ctx;
                //debug!("Exiting: css__parse_azimuth (6)");
                return CSS_INVALID;
            }
            if (unit_val.unwrap() == UNIT_DEG as u32) {
                if ((length_val.unwrap() < -F_360) || (length_val.unwrap() > F_360)) {
                    *ctx = orig_ctx;
                    //debug!("Exiting: css__parse_azimuth (7)");
                    return CSS_INVALID;
                }
            }
            else if (unit_val.unwrap() == UNIT_GRAD as u32) {
                if ((length_val.unwrap() < -F_400) || (length_val.unwrap() > F_400)) {
                    *ctx = orig_ctx;
                    //debug!("Exiting: css__parse_azimuth (8)");
                    return CSS_INVALID;
                }
            } 
            else if (unit_val.unwrap() == UNIT_RAD as u32) {
                if ((length_val.unwrap() < -F_2PI) || (length_val.unwrap() > F_2PI)) {
                    *ctx = orig_ctx;
                    //debug!("Exiting: css__parse_azimuth (9)");
                    return CSS_INVALID;
                }
            }
            value = AZIMUTH_ANGLE;
        }

        css_stylesheet::css__stylesheet_style_appendOPV(style,CSS_PROP_AZIMUTH, flags, value);

        if (((flags & FLAG_INHERIT as u8) == 0) && (value == AZIMUTH_ANGLE)) {
            css_stylesheet::css__stylesheet_style_vappend(style, [return_length_val.unwrap() as u32 , return_unit_val.unwrap() as u32]);
        }

        //debug!("Exiting: css__parse_azimuth (10)");
        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    pub fn css__parse_background(sheet:@mut css_stylesheet, lwc_ref:&mut ~lwc, strings: &css_propstrings, vector:&~[css_token], ctx:@mut uint, result:@mut css_style) -> css_error {
        //debug!("Entering: css__parse_background");
        let orig_ctx = *ctx;
        let mut prev_ctx;
        let mut error = CSS_OK; 
        let mut attachment = true;
        let mut color = true;
        let mut image = true;
        let mut position = true;
        let mut repeat = true;
        let mut attachment_style:@mut css_style;
        let mut color_style:@mut css_style;
        let mut image_style:@mut css_style;
        let mut position_style:@mut css_style;
        let mut repeat_style:@mut css_style;
        

        /* Firstly, handle inherit */
        if *ctx >= vector.len() {
            return CSS_INVALID   
        }
            
        let mut token = &vector[*ctx];
            
        if is_css_inherit(strings, lwc_ref,  token) {
            css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_ATTACHMENT);
            css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_COLOR);
            css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_IMAGE);
            css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_POSITION);
            css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_BACKGROUND_REPEAT);
            if *ctx >= vector.len() {
                return CSS_INVALID   
            }
            // token = &vector[*ctx];
            *ctx +=1; //Iterate
            return CSS_OK
        } 

        /* allocate styles */
        attachment_style = css_stylesheet::css__stylesheet_style_create(sheet);
        color_style = css_stylesheet::css__stylesheet_style_create(sheet);
        image_style = css_stylesheet::css__stylesheet_style_create(sheet);
        position_style = css_stylesheet::css__stylesheet_style_create(sheet);
        repeat_style = css_stylesheet::css__stylesheet_style_create(sheet);

        /* Attempt to parse the various longhand properties */
        loop {
            prev_ctx = *ctx;
            
            if (is_css_inherit(strings, lwc_ref,  token)) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }

            /* Try each property parser in turn, but only if we
             * haven't already got a value for this property.
             */
            
            if attachment &&  match css__parse_background_attachment(sheet, lwc_ref, strings, vector, ctx, 
                attachment_style) { CSS_OK => {error = CSS_OK ; true}, x =>{ error = x; false}} {
                //debug!("css__parse_background :: in css__parse_background_attachment");
                attachment = false
            } 
            else if color &&  match css__parse_background_color(sheet, lwc_ref, strings, vector, ctx,
                color_style) { CSS_OK => {error = CSS_OK ; true}, x =>{ error = x; false}} {
                //debug!("css__parse_background :: in css__parse_background_color");
                color = false
            } 
            else if image &&  match css__parse_background_image(sheet, lwc_ref, strings, vector, ctx,
                image_style) { CSS_OK => {error = CSS_OK ; true}, x =>{ error = x; false}} {
                //debug!("css__parse_background :: in css__parse_background_image");
                image = false
            } 
            else if position && match css_properties::css__parse_background_position(sheet, lwc_ref, strings, vector, ctx,
             position_style) { CSS_OK => {error = CSS_OK ; true}, x =>{ error = x; false}} {
                //debug!("css__parse_background :: in css__parse_background_position");
                position = false
            } else if repeat && match css__parse_background_repeat(sheet, lwc_ref, strings, vector, ctx,
             repeat_style){ CSS_OK => {error = CSS_OK ; true}, x => {error = x; false}} {
                //debug!("css__parse_background :: in css__parse_background_repeat");
                repeat = false
            }

            match error {
                CSS_OK => {
                    //debug!("css__parse_background :: in match error CSS_OK");
                    consumeWhitespace(vector, ctx);
                    if *ctx >= vector.len() {
                        break   
                    }
                    token = &vector[*ctx];
                },
                _ =>  {
                    //debug!("css__parse_background :: in match error _");
					break //Forcibly cause loop to exit
                }
            }

            if *ctx == prev_ctx{
                break
            }
        } 

        
		if attachment {
			css_stylesheet::css__stylesheet_style_appendOPV(attachment_style, CSS_PROP_BACKGROUND_ATTACHMENT, 0, 
				BACKGROUND_ATTACHMENT_SCROLL ); 
		
		}

		if color {
			css_stylesheet::css__stylesheet_style_appendOPV(color_style, CSS_PROP_BACKGROUND_COLOR, 0, 
				BACKGROUND_COLOR_TRANSPARENT );
		
		}

		if image {
			css_stylesheet::css__stylesheet_style_appendOPV(image_style, CSS_PROP_BACKGROUND_IMAGE, 0, BACKGROUND_IMAGE_NONE );
		
		}

		if position {
			css_stylesheet::css__stylesheet_style_appendOPV(position_style, CSS_PROP_BACKGROUND_POSITION, 0, 
				BACKGROUND_POSITION_HORZ_LEFT  |  BACKGROUND_POSITION_VERT_TOP )
		
		}

		if repeat {
			css_stylesheet::css__stylesheet_style_appendOPV(repeat_style, CSS_PROP_BACKGROUND_REPEAT, 0,
			 BACKGROUND_REPEAT_REPEAT )
				
		}   
	
		css_stylesheet::css__stylesheet_merge_style(result, attachment_style);
		css_stylesheet::css__stylesheet_merge_style(result, color_style);
		css_stylesheet::css__stylesheet_merge_style(result, image_style);
		css_stylesheet::css__stylesheet_merge_style(result, position_style);
		css_stylesheet::css__stylesheet_merge_style(result, repeat_style);
               
        CSS_OK
    }
 

    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_background_position(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,
        vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_background_position");
        let orig_ctx = *ctx;
        let mut flags:u8 = 0;
        let mut value = [0,0]; //u16
        let mut length= [0,0]; //i32
        let mut unit = [0,0]; //u32
        

        /* [length | percentage | IDENT(left, right, top, bottom, center)]{1,2}
         * | IDENT(inherit) */
         if *ctx >= vector.len() {
            return CSS_INVALID   
        }
            
        let mut token = &vector[*ctx];

        if match token.token_type { CSS_TOKEN_IDENT  => true, _ => false }  
            && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), INHERIT as uint) {
            
            //token = &vector[*ctx]; Value assigned never used
            *ctx += 1;
            flags = FLAG_INHERIT as u8;
        } 
        else {
            let mut second_pass = false;
            let mut i = 0;
			while i< 2 {
                if *ctx >= vector.len() {
                    break   
                }
            
                token = &vector[*ctx];

                match token.token_type {
                    CSS_TOKEN_IDENT  => {
                        if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), LEFT as uint) {
                            value[i] = BACKGROUND_POSITION_HORZ_LEFT 
                        } 
                        else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), RIGHT as uint) {
                            value[i] = BACKGROUND_POSITION_HORZ_RIGHT 
                        } 
                        else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), TOP as uint) {
                            value[i] = BACKGROUND_POSITION_VERT_TOP 
                        }
                        else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), BOTTOM as uint) {
                            value[i] = BACKGROUND_POSITION_VERT_BOTTOM 
                        }
                        else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), CENTER as uint) {
                            value[i] = BACKGROUND_POSITION_VERT_CENTER 
                        }
                        else if (i == 1) {
                            /* Second pass, so ignore this one */
                            break;
                        } else {
                            /* First pass, so invalid */
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }

                        *ctx += 1; //Iterate
                    },    
                
                    CSS_TOKEN_DIMENSION | CSS_TOKEN_NUMBER | CSS_TOKEN_PERCENTAGE => {
                        match css__parse_unit_specifier(sheet, lwc_ref, vector, ctx, UNIT_PX as u32){                               
                            (Some(length_val), Some(unit_val), CSS_OK) => {
                                length[i] = length_val as i32;
                                unit[i] = unit_val
                            },
                            (_,_,error) => {
                                *ctx = orig_ctx;
                                return error;
                            }
                        }
                                                
                        if (unit[i] & UNIT_ANGLE as u32) != 0 || (unit[i] & UNIT_TIME as u32) != 0 || (unit[i] & UNIT_FREQ as u32) != 0 {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }

                        /* We'll fix this up later, too */
                        value[i] = BACKGROUND_POSITION_VERT_SET ;
                    }, 
                    _  => {
                        if i == 1 {
                            /* Second pass, so ignore */
                            second_pass = true;
                            break;
                        } 
                        else {
                            /* First pass, so invalid */
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                    }
                }    
                consumeWhitespace(vector, ctx);
				i = i + 1;
            }

            //assert(i != 0);

            /* Now, sort out the mess we've got */
            if second_pass {
                assert!(BACKGROUND_POSITION_VERT_CENTER == BACKGROUND_POSITION_HORZ_CENTER);

                /* Only one value, so the other is center */
                if value[0] == BACKGROUND_POSITION_HORZ_LEFT  ||
                    value[0] == BACKGROUND_POSITION_HORZ_RIGHT  || 
                    value[0] == BACKGROUND_POSITION_VERT_CENTER  ||
                    value[0] == BACKGROUND_POSITION_VERT_TOP  ||
                    value[0] == BACKGROUND_POSITION_VERT_BOTTOM  {

                }
                else if value[0] == BACKGROUND_POSITION_VERT_SET  {
                  value[0] = BACKGROUND_POSITION_HORZ_SET  
                } 
                
                value[1] = BACKGROUND_POSITION_VERT_CENTER ;
            } 
            else if value[0] != BACKGROUND_POSITION_VERT_SET  && value[1] != BACKGROUND_POSITION_VERT_SET  {
                /* Two keywords. Verify the axes differ */
                if (((value[0] & 0xf) != 0 && (value[1] & 0xf) != 0) || ((value[0] & 0xf0) != 0 && (value[1] & 0xf0) != 0)) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            } 
            else {
                /* One or two non-keywords. First is horizontal */
                if value[0] == BACKGROUND_POSITION_VERT_SET  {
                    value[0] = BACKGROUND_POSITION_HORZ_SET 
                }
                    

                /* Verify the axes differ */
                if (((value[0] & 0xf) != 0 && (value[1] & 0xf) != 0) ||
                        ((value[0] & 0xf0) != 0 && 
                            (value[1] & 0xf0) != 0)) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            }
        }

        css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_BACKGROUND_POSITION, flags, value[0] | value[1]);
        

        if ((flags & FLAG_INHERIT as u8) == 0) {
            if value[0] == BACKGROUND_POSITION_HORZ_SET  {
                css_stylesheet::css__stylesheet_style_append(style, length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style, unit[0])
            }
            if (value[1] == BACKGROUND_POSITION_VERT_SET ) {
                css_stylesheet::css__stylesheet_style_append(style, length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style, unit[1])
            }
        }

        return CSS_OK;
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_border(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_border");
        let orig_ctx = *ctx;
        let mut error: css_error;

        error = css__parse_border_side(sheet, lwc_ref, strings , vector , ctx , style , BORDER_SIDE_TOP);
        match error {
            CSS_OK => {},
            _=> {
                *ctx = orig_ctx;
                return error;
            }
        }

        *ctx = orig_ctx;
        error = css__parse_border_side(sheet, lwc_ref, strings , vector , ctx , style , BORDER_SIDE_RIGHT);
        match error {
            CSS_OK => {},
            _=> {
                *ctx = orig_ctx;
                return error;
            }
        }

        *ctx = orig_ctx;
        error = css__parse_border_side(sheet, lwc_ref, strings , vector , ctx , style , BORDER_SIDE_BOTTOM);
        match error {
            CSS_OK => {},
            _=> {
                *ctx = orig_ctx;
                return error;
            }
        }

        *ctx = orig_ctx;
        error = css__parse_border_side(sheet, lwc_ref, strings , vector , ctx , style , BORDER_SIDE_LEFT);
        match error {
            CSS_OK => {},
            _=> {
                *ctx = orig_ctx;
            }
        }
        return error;
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_border_color(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_border_color");
        let orig_ctx = *ctx;
        let mut prev_ctx: uint;
        let mut side_count: u32 = 0;


        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        let mut token=&vector[*ctx];

        if is_css_inherit(strings, lwc_ref, token) {
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_BORDER_TOP_COLOR);
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_BORDER_RIGHT_COLOR);
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_BORDER_BOTTOM_COLOR);
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_BORDER_LEFT_COLOR);
            *ctx = *ctx + 1;
            return CSS_OK;
        }

        let mut side_val_vec: ~[u16] = ~[]; 
        let mut side_color_vec: ~[u32] = ~[];

        loop {
            prev_ctx = *ctx;
            if is_css_inherit(strings, lwc_ref, token) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
            let (side_val,side_color , result) = css__parse_color_specifier(sheet, lwc_ref, strings , vector , ctx);

            match result {
                CSS_OK => {
                    side_count += 1;
                    consumeWhitespace(vector , ctx);
                    
                    side_val_vec.push(side_val.unwrap());
                    side_color_vec.push(side_color.unwrap());

                    if *ctx >= vector.len() {
                        break;
                    }

                    token=&vector[*ctx];
                },
                _ => {
                    side_val_vec.push(0);
                    side_color_vec.push(0);
                    break
                }
            }
            if !(*ctx != prev_ctx && side_count < 4) {
                break;
            }
        }

        match side_count {
            1 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_COLOR , 0 , side_val_vec[0]);
                if side_val_vec[0] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_color_vec[0] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_COLOR , 0 , side_val_vec[0]);
                if side_val_vec[0] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_color_vec[0] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_COLOR , 0 , side_val_vec[0]);
                if side_val_vec[0] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_color_vec[0] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_COLOR , 0 , side_val_vec[0]);
                if side_val_vec[0] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_color_vec[0] as u32)
                }
            },
            2 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_COLOR , 0 , side_val_vec[0]);
                if side_val_vec[0] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_color_vec[0] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_COLOR , 0 , side_val_vec[1]);
                if side_val_vec[1] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_color_vec[1] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_COLOR , 0 , side_val_vec[0]);
                if side_val_vec[0] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_color_vec[0] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_COLOR , 0 , side_val_vec[1]);
                if side_val_vec[1] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_color_vec[1] as u32)
                }
            },
            3 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_COLOR , 0 , side_val_vec[0]);
                if side_val_vec[0] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_color_vec[0] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_COLOR , 0 , side_val_vec[1]);
                if side_val_vec[1] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_color_vec[1] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_COLOR , 0 , side_val_vec[2]);
                if side_val_vec[2] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_color_vec[2] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_COLOR , 0 , side_val_vec[1]);
                if side_val_vec[1] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_color_vec[1] as u32)
                }
            },
            4 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_COLOR , 0 , side_val_vec[0]);
                if side_val_vec[0] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_color_vec[0] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_COLOR , 0 , side_val_vec[1]);
                if side_val_vec[1] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_color_vec[1] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_COLOR , 0 , side_val_vec[2]);
                if side_val_vec[2] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_color_vec[2] as u32)
                }
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_COLOR , 0 , side_val_vec[3]);
                if side_val_vec[3] == BORDER_COLOR_SET  {
                    css_stylesheet::css__stylesheet_style_append(style , side_color_vec[3] as u32)
                }
            },
            _ => {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_border_spacing(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_border_spacing");
        let orig_ctx = *ctx;
        let mut error: css_error; 
        let mut length:~[i32] = ~[];
        let mut unit:~[u32] = ~[];

        /* Firstly, handle inherit */
        if *ctx >= vector.len() {
            return CSS_INVALID   
        }
            
        let token = &vector[*ctx];

        if ( 
            match (token.token_type) {
                CSS_TOKEN_IDENT  => true,
                _=> false
            } && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), INHERIT as uint) 
        ) {
            *ctx += 1;
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_SPACING , FLAG_INHERIT as u8 , 0);
        }
        else {
            let mut num_lengths :int;
            let (length_opt,unit_opt,result) = css__parse_unit_specifier(sheet, lwc_ref, vector, ctx, UNIT_PX as u32);

            error =result;
            match error {
                CSS_OK=> {
                    length.push(length_opt.unwrap() as i32);
                    unit.push(unit_opt.unwrap());
                    
                    if (unit[0] & UNIT_ANGLE as u32) > 0  || (unit[0] & UNIT_TIME as u32) > 0  || 
                        (unit[0] & UNIT_FREQ as u32) > 0  || (unit[0] & UNIT_PCT as u32 ) > 0 {

                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    num_lengths = 1;
                    consumeWhitespace(vector, ctx);

                    if *ctx < vector.len() {
                        let (length_opt,unit_opt,result) = css__parse_unit_specifier(sheet, lwc_ref, vector, ctx, UNIT_PX as u32);
                        if length_opt.is_some() {
                            length.push(length_opt.unwrap() as i32);    
                        }
                        else {
                            length.push(0);
                        }
                        if unit_opt.is_some() {
                            unit.push(unit_opt.unwrap());    
                        }
                        else {
                            unit.push(0);
                        }
                        
                        error =result;
                         match error {
                            CSS_OK=> {
                                if (unit[1] & UNIT_ANGLE as u32) > 0 ||
                                   (unit[1] & UNIT_TIME as u32) > 0 ||
                                   (unit[1] & UNIT_FREQ  as u32) > 0 ||
                                   (unit[1] & UNIT_PCT as u32) > 0 {
                    
                                    *ctx = orig_ctx;
                                    return CSS_INVALID;
                                }
                                num_lengths = 2;
                            },
                            _=>{}
                        }
                    }//end of *ctx < vector.len()
                    if (num_lengths == 1) {
                     /* Only one length specified. Use for both axes. */
                        length.push(length[0]);
                        unit.push(unit[0]);
                    }

                    /* Lengths must not be negative */
                    if (length[0] < 0 || length[1] < 0) {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_BORDER_SPACING, 0, BORDER_SPACING_SET );
                    css_stylesheet::css__stylesheet_style_vappend(style,[ length[0] as u32, unit[0] , length[1] as u32, unit[1] ]); 
                },
                _=>{
                   *ctx = orig_ctx;
                    return error; 
                }
            }
        }
        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_border_style(_: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_border_style");
        let orig_ctx = *ctx;
        let mut prev_ctx: uint;
        let mut token: &css_token;
        let mut side_count: u32 = 0;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        token=&vector[*ctx];

        if is_css_inherit(strings, lwc_ref, token) {
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_BORDER_TOP_STYLE);
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_BORDER_RIGHT_STYLE);
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_BORDER_BOTTOM_STYLE);
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_BORDER_LEFT_STYLE);
            *ctx = *ctx + 1;
            return CSS_OK;
        }

        let mut side_val_vec: ~[u16] = ~[]; 
        loop {
            prev_ctx = *ctx;
            if is_css_inherit(strings, lwc_ref, token) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }

            match token.token_type {
                CSS_TOKEN_IDENT  => {
                    if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), NONE as uint) {
                        side_val_vec.push(BORDER_STYLE_NONE );
                    }
                    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), HIDDEN as uint) {
                        side_val_vec.push(BORDER_STYLE_HIDDEN );
                    }
                    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), DOTTED as uint) {
                        side_val_vec.push(BORDER_STYLE_DOTTED );
                    }
                    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), DASHED as uint) {
                        side_val_vec.push(BORDER_STYLE_DASHED );
                    }
                    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), SOLID as uint) {
                        side_val_vec.push(BORDER_STYLE_SOLID );
                    }
                    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), LIBCSS_DOUBLE as uint) {
                        side_val_vec.push(BORDER_STYLE_DOUBLE );
                    }
                    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), GROOVE as uint) {
                        side_val_vec.push(BORDER_STYLE_GROOVE );
                    }
                    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), RIDGE as uint) {
                        side_val_vec.push(BORDER_STYLE_RIDGE );
                    }
                    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), INSET as uint) {
                        side_val_vec.push(BORDER_STYLE_INSET );
                    }
                    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), OUTSET as uint) {
                        side_val_vec.push(BORDER_STYLE_OUTSET );
                    }
                    else {
                        break;
                    }
                },
                _ => {
                    break
                }
            }
            side_count += 1;
            *ctx = *ctx + 1;
            consumeWhitespace(vector , ctx);
            
            if *ctx >= vector.len() {
                break;
            }

            token=&vector[*ctx];

            if !(*ctx != prev_ctx && side_count < 4) {
                break;
            }
        }
        match side_count {
            1 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_STYLE , 0 , side_val_vec[0]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_STYLE , 0 , side_val_vec[0]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_STYLE , 0 , side_val_vec[0]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_STYLE , 0 , side_val_vec[0]);
            },
            2 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_STYLE , 0 , side_val_vec[0]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_STYLE , 0 , side_val_vec[1]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_STYLE , 0 , side_val_vec[0]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_STYLE , 0 , side_val_vec[1]);
            },
            3 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_STYLE , 0 , side_val_vec[0]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_STYLE , 0 , side_val_vec[1]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_STYLE , 0 , side_val_vec[2]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_STYLE , 0 , side_val_vec[1]);
            },
            4 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_STYLE , 0 , side_val_vec[0]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_STYLE , 0 , side_val_vec[1]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_STYLE , 0 , side_val_vec[2]);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_STYLE , 0 , side_val_vec[3]);
            },
            _ => {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_border_width(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
       
        //debug!("Entering: css__parse_border_width");
        let orig_ctx = *ctx;
        let mut error: css_error;
        let mut token: &css_token;
        let mut side_val: ~[u16] = ~[];
        let mut side_length: ~[i32] = ~[];
        let mut side_unit: ~[u32] = ~[];
        let mut side_count: u32 = 0;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        token=&vector[*ctx];

        if is_css_inherit(strings, lwc_ref, token) {
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_BORDER_TOP_WIDTH);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_BORDER_RIGHT_WIDTH);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_BORDER_BOTTOM_WIDTH);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_BORDER_LEFT_WIDTH);
            *ctx += 1;
            return CSS_OK;
        }
        let mut prev_ctx: uint;

        loop {
            prev_ctx = *ctx;
            if is_css_inherit(strings, lwc_ref, token) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
            if (
                match token.token_type {
                    CSS_TOKEN_IDENT  => true,
                    _ => false
                }
                ) && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), THIN as uint) {

                side_val.push(BORDER_WIDTH_THIN);
                side_unit.push(0);
                side_length.push(0);
                *ctx = *ctx + 1;
                error = CSS_OK;
            }
            else if (
                match token.token_type {
                    CSS_TOKEN_IDENT  => true,
                    _ => false
                }
                ) && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), MEDIUM as uint) {
                
                side_val.push(BORDER_WIDTH_MEDIUM);
                side_unit.push(0);
                side_length.push(0);
                *ctx = *ctx + 1;
                error = CSS_OK;
            }
            else if (match token.token_type {
                CSS_TOKEN_IDENT  => true,
                _ => false
            }) && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), THICK as uint) {
                
                side_val.push(BORDER_WIDTH_THICK);
                side_unit.push(0);
                side_length.push(0);
                *ctx = *ctx + 1;
                error = CSS_OK;
            }
            else {
                side_val.push(BORDER_WIDTH_SET);
                let (length , unit , result) = css__parse_unit_specifier(sheet, lwc_ref, vector, ctx, UNIT_PX as u32);
                if length.is_some() {
                    side_length.push(length.unwrap());
                }
                else {
                    side_length.push(0);
                }
                if unit.is_some() {
                    side_unit.push(unit.unwrap());
                }
                else {
                    side_unit.push(0);    
                }
                error = result;
                match result {
                    CSS_OK => {
                        if (side_unit[side_count] == (UNIT_PCT as u32)) {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                        if (side_unit[side_count] & (UNIT_ANGLE as u32)) > 0 {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                        if (side_unit[side_count] & (UNIT_TIME as u32)) > 0{
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                        if (side_unit[side_count] & (UNIT_FREQ as u32)) > 0{
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }

                        if side_length[side_count] < 0 {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                    },
                    _ => {}
                }
            }
            match error {
                CSS_OK => {
                    side_count += 1;
                    consumeWhitespace(vector , ctx);

                    if *ctx >= vector.len() {
                        break;
                    }

                    token=&vector[*ctx];
                }
                _ => {
                    break
                }
            }
            if !(*ctx != prev_ctx && side_count < 4) {
                break;
            }
        }
        match side_count {
            1 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_WIDTH , 0 , side_val[0]);
                
                if side_val[0] == BORDER_WIDTH_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                }
                
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_WIDTH , 0 , side_val[0]);
                
                if side_val[0] == BORDER_WIDTH_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_WIDTH , 0 , side_val[0]);
                
                if side_val[0] == BORDER_WIDTH_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_WIDTH , 0 , side_val[0]);
                
                if side_val[0] == BORDER_WIDTH_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                }
            },
            2 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_WIDTH , 0 , side_val[0]);
                
                if side_val[0] == BORDER_WIDTH_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_WIDTH , 0 , side_val[1]);
                
                if side_val[1] == BORDER_WIDTH_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_WIDTH , 0 , side_val[0]);
                
                if side_val[0] == BORDER_WIDTH_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_WIDTH , 0 , side_val[1]);
                
                if side_val[1] == BORDER_WIDTH_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                }

            },
            3 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_WIDTH , 0 , side_val[0]);
                
                if side_val[0] == BORDER_WIDTH_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_WIDTH , 0 , side_val[1]);
                
                if side_val[1] == BORDER_WIDTH_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_WIDTH , 0 , side_val[2]);
                
                if side_val[2] == BORDER_WIDTH_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[2] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[2] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_WIDTH , 0 , side_val[1]);
                
                if side_val[1] == BORDER_WIDTH_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                }

            },
            4 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_TOP_WIDTH , 0 , side_val[0]);
                
                if side_val[0] == BORDER_WIDTH_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_RIGHT_WIDTH , 0 , side_val[1]);
                
                if side_val[1] == BORDER_WIDTH_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_BOTTOM_WIDTH , 0 , side_val[2]);
                
                if side_val[2] == BORDER_WIDTH_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[2] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[2] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_BORDER_LEFT_WIDTH , 0 , side_val[3]);
                
                if side_val[3] == BORDER_WIDTH_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[3] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[3] as u32);
                }
            },
            _ => {
                *ctx = orig_ctx;
            }
        }
        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_clip(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
       
        //debug!("Entering: css__parse_clip");
        let orig_ctx = *ctx;
        let mut token:&css_token;
        let mut num_lengths: int = 0;
        let mut length: ~[i32] = ~[];
        let mut unit: ~[u32] = ~[]; 

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        token=&vector[*ctx];
        *ctx = *ctx + 1;

        match token.token_type {
            CSS_TOKEN_IDENT  => {
                if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), INHERIT as uint) {
                    css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_CLIP , FLAG_INHERIT as u8 , 0);
                }
                else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), AUTO as uint) {
                    css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_CLIP , 0 , CLIP_AUTO );
                }
            },
            CSS_TOKEN_FUNCTION  => {

                if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), RECT as uint) {
                    let mut i: int = 0;
                    let mut value: u16 = CLIP_SHAPE_RECT ;

                    while i < 4 {
                        consumeWhitespace(vector , ctx);

                        if *ctx >= vector.len() {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }

                        token=&vector[*ctx];

                        match token.token_type {
                            CSS_TOKEN_IDENT  => {
                                if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), AUTO as uint) {
                                    value |= 1 << (i+3);
                                }
                                else {
                                    *ctx = orig_ctx;
                                    return CSS_INVALID;
                                }
                                *ctx = *ctx + 1;
                            }
                            _ => {
                                let (length_val , unit_val , result) = css__parse_unit_specifier(sheet, lwc_ref, vector, ctx, UNIT_PX as u32);
                                
                                match result {
                                    CSS_OK => {},
                                    _ => {
                                        *ctx = orig_ctx;
                                        return result;
                                    }
                                }
                                length.push(length_val.unwrap() as i32);
                                unit.push(unit_val.unwrap());
                                if (unit[num_lengths] & (UNIT_ANGLE as u32)) > 0 {
                                    *ctx = orig_ctx;
                                    return CSS_INVALID;
                                }
                                if (unit[num_lengths] & (UNIT_TIME as u32)) > 0{
                                    *ctx = orig_ctx;
                                    return CSS_INVALID;
                                }
                                if (unit[num_lengths] & (UNIT_FREQ as u32)) > 0{
                                    *ctx = orig_ctx;
                                    return CSS_INVALID;
                                }
                                if (unit[num_lengths] & (UNIT_PCT as u32)) > 0{
                                    *ctx = orig_ctx;
                                    return CSS_INVALID;
                                }
                                num_lengths += 1;
                            }
                                    
                        }
                        consumeWhitespace(vector , ctx);
                        if i<3 {
                            if *ctx >= vector.len() {
                                *ctx = orig_ctx;
                                return CSS_INVALID;
                            }
                            token=&vector[*ctx];
                            if tokenIsChar(token, lwc_ref,  ',') {
                                *ctx = *ctx + 1;
                            }
                        }
                        i += 1;
                    }

                    /* Finally, consume closing parenthesis */
                    consumeWhitespace(vector , ctx);
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    token=&vector[*ctx];
                    *ctx = *ctx + 1;

                    if (tokenIsChar(token, lwc_ref,  ')') == false) {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_CLIP , 0 , value);

                    i = 0;
                    while i < num_lengths {

                        css_stylesheet::css__stylesheet_style_vappend(style,[ length[i] as u32, unit[i]]);
                        i += 1;
                    }
                }
            },
            _ => {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_columns(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_columns");
        let orig_ctx = *ctx;
        let mut prev_ctx:uint;
        let mut token: &css_token;
        let mut width = true;
        let mut count = true;
        let mut error: css_error;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        token=&vector[*ctx];
        
        if (is_css_inherit(strings, lwc_ref,  token)) {
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_COLUMN_WIDTH);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_COLUMN_COUNT);
            *ctx += 1;
            return CSS_OK;
        }

        let width_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let count_style = css_stylesheet::css__stylesheet_style_create(sheet);

        loop {
            //debug!("css__parse_columns :: Entering loop");
            prev_ctx = *ctx;
            error = CSS_OK;
            if (is_css_inherit(strings, lwc_ref,  token)) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }

            if width && {error = css__parse_column_width(sheet , lwc_ref, strings ,vector, ctx,  width_style); error} as int == CSS_OK as int { 
              
                //debug!("Entering: css__parse_columns :: if(width)  :: error == %? , count == %? , width == %?" , error , count , width); 
                width = false;
            }
            else if count && {error = css__parse_column_count(sheet , lwc_ref, strings ,vector, ctx,  count_style); error} as int == CSS_OK as int {

                //debug!("Entering: css__parse_columns :: else if count  :: error == %? , count == %? , width == %?" , error , count , width);
                count = false;
            }
            
            if error as int == CSS_OK as int {
                consumeWhitespace(vector, ctx);
                if *ctx >= vector.len() {
                    break;
                }
                token = &vector[*ctx];
            }
            else {
                break
            }

            if *ctx == prev_ctx {
                break;
            }
        }//end of loop

        if width {
            css_stylesheet::css__stylesheet_style_appendOPV(width_style, CSS_PROP_COLUMN_WIDTH, 0, COLUMN_WIDTH_AUTO);
        }
        if count {
            css_stylesheet::css__stylesheet_style_appendOPV(count_style, CSS_PROP_COLUMN_COUNT, 0, COLUMN_COUNT_AUTO);
        }
        css_stylesheet::css__stylesheet_merge_style(style , width_style);
        css_stylesheet::css__stylesheet_merge_style(style , count_style);

        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_column_rule(sheet: @mut css_stylesheet, lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
       
        //debug!("Entering: css__parse_column_rule");
        let orig_ctx = *ctx;
        let mut color = true;
        let mut bool_style = true;
        let mut width = true;
        let mut error: css_error = CSS_OK;
        let mut token: &css_token;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        token=&vector[*ctx];

        if is_css_inherit(strings, lwc_ref, token) {
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_COLUMN_RULE_COLOR);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_COLUMN_RULE_STYLE);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_COLUMN_RULE_WIDTH);
            *ctx = *ctx + 1;
            return CSS_OK;
        }

        let color_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let style_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let width_style = css_stylesheet::css__stylesheet_style_create(sheet);

        let mut prev_ctx: uint;

        loop {
            prev_ctx = *ctx;

            if *ctx >= vector.len() {
                return CSS_INVALID;
            }
            
            token=&vector[*ctx];
            if is_css_inherit(strings, lwc_ref, token) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }

            if ((color) && 
                (match (css__parse_column_rule_color(sheet , lwc_ref, strings , vector , ctx , color_style)) {
                    CSS_OK => true,
                    _ => false
                })) {
                color = false;
                error = CSS_OK;
            }
            
            else if (bool_style) && 
                (match (css__parse_column_rule_style(sheet , lwc_ref, strings , vector , ctx , style_style)) {
                    CSS_OK => true,
                    _ => false
                }) {
                bool_style = false;
                error = CSS_OK;
            }
            else if (width) && 
                (match (css__parse_column_rule_width(sheet , lwc_ref, strings , vector , ctx , width_style)) {
                    CSS_OK => true,
                    _ => false
                }) {
                width = false;
                error = CSS_OK;
            }
            match error {
                CSS_OK => {
                    consumeWhitespace(vector , ctx);

                    if *ctx >= vector.len() {
                        break;
                    }
                },
                _ => {
                    break;
                }
            }
            if (*ctx == prev_ctx) {
                break;
            }
        }

        if color {
            css_stylesheet::css__stylesheet_style_appendOPV(color_style , CSS_PROP_COLUMN_RULE_COLOR , 0 , COLUMN_RULE_COLOR_SET );
            css_stylesheet::css__stylesheet_style_append(color_style , 0x00000000);
        }
        if bool_style {
            css_stylesheet::css__stylesheet_style_appendOPV(style_style , CSS_PROP_COLUMN_RULE_STYLE , 0 , COLUMN_RULE_STYLE_NONE );   
        }
        if width {
            css_stylesheet::css__stylesheet_style_appendOPV(width_style , CSS_PROP_COLUMN_RULE_WIDTH , 0 , COLUMN_RULE_WIDTH_MEDIUM );
        }

        css_stylesheet::css__stylesheet_merge_style(style , color_style);
        css_stylesheet::css__stylesheet_merge_style(style , style_style);
        css_stylesheet::css__stylesheet_merge_style(style , width_style);
        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_content(sheet: @mut css_stylesheet, lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, result: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_content");
        let orig_ctx = *ctx;
        let mut error:css_error = CSS_OK;                
        /* IDENT(normal, none, inherit) | [ ... ]+ */
        
        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        let mut token=&vector[*ctx];
        *ctx = *ctx + 1; //Iterate

        let token_ident_match_res = match token.token_type { CSS_TOKEN_IDENT  => true, _ => false};

        if token_ident_match_res && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), INHERIT as uint) {
           css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_CONTENT)        
        }
        else if token_ident_match_res && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), NORMAL as uint) {
           css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_CONTENT, 0, CONTENT_NORMAL )
        } 
        else if token_ident_match_res && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), NONE as uint) {
           css_stylesheet::css__stylesheet_style_appendOPV(result, CSS_PROP_CONTENT, 0, CONTENT_NONE )
        } 
        else {

            /* Macro to output the value marker, awkward because we need to check
             * first to determine how the value is constructed.
             */
            let CSS_APPEND = |first, CSSVAL| css_stylesheet::css__stylesheet_style_append(result, if first {buildOPV(CSS_PROP_CONTENT, 0, CSSVAL)} else {CSSVAL as u32});

            let mut first = true;
            let mut prev_ctx = orig_ctx;

            /* [
             *   IDENT(open-quote, close-quote, no-open-quote,
             *         no-close-quote) |
             *   STRING |
             *   URI |
             *   FUNCTION(attr) IDENT ')' |
             *   FUNCTION(counter) IDENT IDENT? ')' |
             *   FUNCTION(counters) IDENT STRING IDENT? ')'
             * ]+
             */

            loop {

                if token_ident_match_res && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), 
                 OPEN_QUOTE as uint) {
                    CSS_APPEND(first, CONTENT_OPEN_QUOTE )
                }
                else if token_ident_match_res && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), 
                 CLOSE_QUOTE as uint) {
                    CSS_APPEND(first, CONTENT_CLOSE_QUOTE )
                }
                else if token_ident_match_res && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), 
                 NO_OPEN_QUOTE as uint) {
                    CSS_APPEND(first, CONTENT_NO_OPEN_QUOTE );
                } 
                else if token_ident_match_res && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), 
                 NO_CLOSE_QUOTE as uint) {
                    CSS_APPEND(first, CONTENT_NO_CLOSE_QUOTE );
                } 
                else if match token.token_type {CSS_TOKEN_STRING  => true, _ => false} {
                    
                    let snumber = sheet.css__stylesheet_string_add(token.idata.unwrap()) ;
                    CSS_APPEND(first, CONTENT_STRING );
                    
                    css_stylesheet::css__stylesheet_style_append(result, snumber as u32);
                }
                else if match token.token_type {CSS_TOKEN_URI  => true, _ => false} {
                    
                    match (*sheet.resolve)(sheet.url, token.idata.get_ref().clone()){
                        (CSS_OK, Some(uri)) => {
                            let uri_snumber = sheet.css__stylesheet_string_add(uri);
                            CSS_APPEND(first, CONTENT_URI);
                    
                            css_stylesheet::css__stylesheet_style_append(result, uri_snumber as u32)
                        },
                        (error, _ ) => {
                            *ctx = orig_ctx;
                            return error
                        }
                    }
                } 
                else if match token.token_type {CSS_TOKEN_FUNCTION  => true, _ => false} &&
                        strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), ATTR as uint) {

                    consumeWhitespace(vector, ctx);

                    /* Expect IDENT */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    *ctx = *ctx + 1; //Iterate
                    
                    match token.token_type { 
                        CSS_TOKEN_IDENT  => {},
                        _ => {
                            *ctx = orig_ctx;
                            return CSS_INVALID
                        }
                    }   
                    
                    let snumber = sheet.css__stylesheet_string_add(token.idata.unwrap());
                    CSS_APPEND(first, CONTENT_ATTR );
                    
                    css_stylesheet::css__stylesheet_style_append(result, snumber as u32);

                    consumeWhitespace(vector, ctx);

                    /* Expect ')' */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    *ctx = *ctx + 1; //Iterate
                    
                    if !tokenIsChar(token, lwc_ref,  ')') {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                }
                else if match token.token_type {CSS_TOKEN_FUNCTION  => true, _ => false} &&
                       strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), COUNTER as uint) {

                    let mut opv = CONTENT_COUNTER as u32;

                    consumeWhitespace(vector, ctx);

                    /* Expect IDENT */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    *ctx = *ctx + 1; //Iterate
                    
                    match token.token_type { 
                        CSS_TOKEN_IDENT  => {},
                        _ => {
                            *ctx = orig_ctx;
                            return CSS_INVALID
                        }
                    }   

                    let name = token.idata.unwrap();

                    consumeWhitespace(vector, ctx);

                    /* Possible ',' */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    
                    if !tokenIsChar(token, lwc_ref,  ',') && !tokenIsChar(token, lwc_ref,  ')') {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }

                    if tokenIsChar(token, lwc_ref,  ',') {

                        *ctx += 1;

                        consumeWhitespace(vector, ctx);

                        /* Expect IDENT */
                        if *ctx >= vector.len() {
                            *ctx = orig_ctx;
                            return CSS_INVALID
                        }
                        
                        token=&vector[*ctx]; //peek
                        
                        match token.token_type { 
                            CSS_TOKEN_IDENT  => {},
                            _ => {
                                *ctx = orig_ctx;
                                return CSS_INVALID
                            }
                        }   
                        
                        let value:u32; 
                        match css__parse_list_style_type_value(strings , lwc_ref, token){
                            (Some(val), CSS_OK) => {value = val as u32},
                            ( _, error) => {
                                *ctx = orig_ctx;
                                return error;
                            }
                        }
                        
                        opv |= value << CONTENT_COUNTER_STYLE_SHIFT as uint;

                        *ctx += 1;

                        consumeWhitespace(vector, ctx);
                    } 
                    else {
                        opv |= LIST_STYLE_TYPE_DECIMAL as u32 << CONTENT_COUNTER_STYLE_SHIFT as uint
                    }

                    /* Expect ')' */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    *ctx += 1;
                    if !tokenIsChar(token, lwc_ref,  ')') {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }

                    let snumber = sheet.css__stylesheet_string_add(name);
                    
                    CSS_APPEND(first, opv as u16);
                    
                    css_stylesheet::css__stylesheet_style_append(result, snumber as u32);
                } 
                else if match token.token_type {CSS_TOKEN_FUNCTION  => true, _ => false} &&
                       strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), COUNTERS as uint) {
                                      
                    let mut opv = CONTENT_COUNTERS as u32;

                    consumeWhitespace(vector, ctx);

                    /* Expect IDENT */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                        
                    token=&vector[*ctx];
                    *ctx += 1; //Iterate

                    match token.token_type { 
                        CSS_TOKEN_IDENT  => {},
                        _ => {
                            *ctx = orig_ctx;
                            return CSS_INVALID
                        }
                    }   
                    
                    let name = token.idata.unwrap();

                    consumeWhitespace(vector, ctx);

                    /* Expect ',' */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    *ctx += 1; //Iterate

                    if !tokenIsChar(token, lwc_ref,  ',') {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    
                    consumeWhitespace(vector, ctx);

                    /* Expect STRING */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    *ctx += 1; //Iterate

                    match token.token_type{
                        CSS_TOKEN_STRING  => {},
                        _ => { 
                            *ctx = orig_ctx;
                            return CSS_INVALID
                        }
                    }    

                    let sep = token.idata.unwrap();

                    consumeWhitespace(vector, ctx);

                    /* Possible ',' */
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];

                    if !tokenIsChar(token, lwc_ref,  ',') && !tokenIsChar(token, lwc_ref,  ')') {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }

                    if tokenIsChar(token, lwc_ref,  ',') {
                                               
                       *ctx += 1;

                        consumeWhitespace(vector, ctx);

                        /* Expect IDENT */
                         if *ctx >= vector.len() {
                            *ctx = orig_ctx;
                            return CSS_INVALID
                        }
                    
                        token=&vector[*ctx];
                        
                        match token.token_type {
                            CSS_TOKEN_IDENT  => {},
                            _ => {
                                *ctx = orig_ctx;
                                return CSS_INVALID;
                            }
                        }    

                        let value:u32; 
                        match css__parse_list_style_type_value(strings , lwc_ref, token){
                            (Some(val), CSS_OK) => {value = val as u32},
                            ( _, error) => {
                                *ctx = orig_ctx;
                                return error;
                            }
                        }
                        
                        opv |= value as u32 << CONTENT_COUNTERS_STYLE_SHIFT as uint;

                        *ctx += 1;

                        consumeWhitespace(vector, ctx);
                    } 
                    else {
                        opv |= LIST_STYLE_TYPE_DECIMAL as u32 << CONTENT_COUNTERS_STYLE_SHIFT as uint;
                    }

                    /* Expect ')' */
                    
                    if *ctx >= vector.len() {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }
                    
                    token=&vector[*ctx];
                    *ctx += 1; //Iterate


                    if !tokenIsChar(token, lwc_ref,  ')') {
                        *ctx = orig_ctx;
                        return CSS_INVALID
                    }


                    let name_snumber = sheet.css__stylesheet_string_add(name);
                   
                    let sep_snumber = sheet.css__stylesheet_string_add(sep);
                    
                    CSS_APPEND(first, opv as u16);
                    
                    css_stylesheet::css__stylesheet_style_append(result, name_snumber as u32);
                    
                    css_stylesheet::css__stylesheet_style_append(result, sep_snumber as u32)
                }
                else if (first) {
                    /* Invalid if this is the first iteration */
                    error = CSS_INVALID;
                } 
                else {
                    /* Give up, ensuring current token is reprocessed */
                    *ctx = prev_ctx;
                    error = CSS_OK;
                    break;
                }

                /* if there was an error bail */
                match error {
                    CSS_OK => {},
                     _ => {
                        *ctx = orig_ctx;
                        return error;
                    }
                }    

                first = false;

                consumeWhitespace(vector, ctx);
                prev_ctx = *ctx;
                
                if *ctx >= vector.len() {
                    break
                }
                
                token=&vector[*ctx];
                *ctx += 1; //Iterate
            } /* loop */


            /* Write list terminator */
            css_stylesheet::css__stylesheet_style_append(result, CONTENT_NORMAL as u32);
        }

        match error {
            CSS_OK => {},
             _ => {
                *ctx = orig_ctx;
                return error;
            }
        }    
    
        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_cue(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_cue");
        //debug!(fmt!("css__parse_cue: style1 == %?" , style));
        let orig_ctx = *ctx;
        let mut error: css_error;
        let token: &css_token;
        let first_token: &css_token;

        first_token=&vector[*ctx];

        error = css__parse_cue_before(sheet , lwc_ref, strings , vector , ctx , style);

        match error {
            CSS_OK => {
                consumeWhitespace(vector , ctx);

                if *ctx >= vector.len() {
                    *ctx = orig_ctx;
                    error = css__parse_cue_after(sheet , lwc_ref, strings , vector , ctx , style);
                }
                else {
                    token = &vector[*ctx];
                    if is_css_inherit(strings, lwc_ref, token) {
                        error = CSS_INVALID;
                    }
                    else {
                        error = css__parse_cue_after(sheet , lwc_ref, strings , vector , ctx , style);
                        match error {
                            CSS_OK => {
                                if is_css_inherit(strings, lwc_ref, first_token) {
                                    error = CSS_INVALID;
                                }
                            },
                            _ => {
                                *ctx = orig_ctx;
                                error = css__parse_cue_after(sheet , lwc_ref, strings , vector , ctx , style);
                            }           
                        }       
                    }
                }
            },
            _ => {}

        }
        match error {
            CSS_OK => {
                return CSS_OK;
            },
            _ => {
                *ctx = orig_ctx;
                return error
            }
        }
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_cursor(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_cursor");
        let orig_ctx = *ctx;
        let mut token: &css_token;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        token = &vector[*ctx];
        *ctx = *ctx + 1;
        
        match token.token_type {
            CSS_TOKEN_IDENT  =>{},
            CSS_TOKEN_URI  => {},
            _=>{
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }

        if (
            match token.token_type {
                CSS_TOKEN_IDENT  => true,
                _=> false
            } && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), INHERIT as uint)
            ) {
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_CURSOR);
        }
        else {
            let mut first : bool =true;
            let mut uri_snumber:u32;
			let vector_len : uint = vector.len();
            while (*ctx <  vector_len
                && match token.token_type {
                        CSS_TOKEN_URI  => true,
                        _ => false
                   }
                   ) {

                let uri: uint;
                match (*sheet.resolve)(sheet.url, token.idata.get_ref().clone()) {
                    (CSS_OK, Some(x)) => {
                        uri =x;
                    },
                    (error,_) => {
                        *ctx = orig_ctx;
                        return error;
                    }
                }
                uri_snumber = sheet.css__stylesheet_string_add(uri) as u32;
                match first{
                    true=>{
                         css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_URI );
                    },
                    false=>{
                        css_stylesheet::css__stylesheet_style_append(style,CURSOR_URI as u32);
                    }
                }
                css_stylesheet::css__stylesheet_style_append(style,uri_snumber);

                consumeWhitespace(vector, ctx);
                if *ctx >= vector_len {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
                token = &vector[*ctx];
                *ctx = *ctx + 1;

                if tokenIsChar(token, lwc_ref,  ',') == false {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }

                consumeWhitespace(vector, ctx);
                if *ctx >= vector_len {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
                token = &vector[*ctx];
                *ctx = *ctx + 1;
                match token.token_type {
                    CSS_TOKEN_IDENT  =>{},
                    CSS_TOKEN_URI  => {},
                    _=>{
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                }
                first = false;
            }//end of while

            match token.token_type {
                CSS_TOKEN_IDENT =>{
                   if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), AUTO as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_AUTO );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_AUTO as u32);
                            }
                        }
                    }
                   else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), CROSSHAIR as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_CROSSHAIR );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_CROSSHAIR as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), DEFAULT as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_DEFAULT );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_DEFAULT as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), POINTER as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_POINTER );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_POINTER as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), MOVE as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_MOVE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_MOVE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), E_RESIZE as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_E_RESIZE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_E_RESIZE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), NE_RESIZE as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_NE_RESIZE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_NE_RESIZE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), NW_RESIZE as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_NW_RESIZE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_NW_RESIZE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), N_RESIZE as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_N_RESIZE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_N_RESIZE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), SE_RESIZE as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_SE_RESIZE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_SE_RESIZE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), SW_RESIZE as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_SW_RESIZE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_SW_RESIZE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), S_RESIZE as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_S_RESIZE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_S_RESIZE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), W_RESIZE as uint) {
                         match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_W_RESIZE );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_W_RESIZE as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), LIBCSS_TEXT as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_TEXT );
                            },
                            false=>{
                                 css_stylesheet::css__stylesheet_style_append(style,CURSOR_TEXT as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), WAIT as uint) {
                         match first{
                                true=>{
                                    css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_WAIT );
                                },
                                false=>{
                                    css_stylesheet::css__stylesheet_style_append(style,CURSOR_WAIT as u32);
                                }
                            }
                   }
                   else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), HELP as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_HELP );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_HELP as u32);
                            }
                        }
                   }
                   else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), PROGRESS as uint) {
                        match first{
                            true=>{
                                css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_CURSOR, 0,CURSOR_PROGRESS );
                            },
                            false=>{
                                css_stylesheet::css__stylesheet_style_append(style,CURSOR_PROGRESS as u32);
                            }
                        }
                   }
                   else {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                   }
                },
                _=>{}
            }
        }//end else

        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_elevation(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_elevation");
        let orig_ctx:uint = *ctx;
        let mut flags:u8 = 0;
        let mut value:u16= 0;
        let mut length:i32 = 0;
        let mut unit:u32 = 0;
        let mut token: &css_token;

        if *ctx >= vector.len() {
            //debug!("Exiting: css__parse_elevation (1)");
            return CSS_INVALID;
        }
        token=&vector[*ctx];
        
        if (token.token_type as int == CSS_TOKEN_IDENT as int&& 
            strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), INHERIT as uint)) {
            *ctx += 1;
            flags = FLAG_INHERIT as u8;
        }
        else if (token.token_type as int == CSS_TOKEN_IDENT as int &&
            strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), BELOW as uint)) {
                *ctx += 1;
                value = ELEVATION_BELOW ;
            }
        else if (token.token_type as int == CSS_TOKEN_IDENT as int &&
         strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), LEVEL as uint)) {
                *ctx += 1;
                value = ELEVATION_LEVEL ;
            }
        else if (token.token_type as int == CSS_TOKEN_IDENT as int &&
            strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), ABOVE as uint)) {
                *ctx += 1;
                value = ELEVATION_ABOVE ;
            }
        else if (token.token_type as int == CSS_TOKEN_IDENT as int &&
            strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), HIGHER as uint)){
                *ctx += 1;
                value = ELEVATION_HIGHER ;
            }
        else if (token.token_type as int == CSS_TOKEN_IDENT as int &&
            strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), LOWER as uint)) {
                *ctx += 1;
                value = ELEVATION_LOWER ;
            }
        else {
            let (length_ret,unit_ret,error) = css__parse_unit_specifier(sheet, lwc_ref, vector, ctx, UNIT_DEG as u32);
            
            match error {
                CSS_OK=>{
                    length = length_ret.unwrap();
                    unit = unit_ret.unwrap();

                    if ((unit & UNIT_ANGLE) ==0) {
                        *ctx = orig_ctx;
                        //debug!("Exiting: css__parse_elevation (2)");
                        return CSS_INVALID;
                    }
                    /* Valid angles lie between -90 and 90 degrees */
                    if (unit == UNIT_DEG as u32) {
                        if (length < -F_90 as i32 || length > F_90 as i32) {
                            *ctx = orig_ctx;
                            //debug!("Exiting: css__parse_elevation (3)");
                            return CSS_INVALID;
                        }
                    } 
                    else if (unit == UNIT_GRAD as u32) {
                        if (length < -F_100  as i32|| length > F_100 as i32) {
                            *ctx = orig_ctx;
                            //debug!("Exiting: css__parse_elevation (4)");
                            return CSS_INVALID;
                        }
                    } 
                    else if (unit == UNIT_RAD as u32) {
                        if (length < -F_PI_2  as i32|| length > F_PI_2 as i32) {
                            *ctx = orig_ctx;
                            //debug!("Exiting: css__parse_elevation (5)");
                            return CSS_INVALID;
                        }
                    }
                    value = ELEVATION_ANGLE ;
                },
                _=>{
                    *ctx = orig_ctx;
                    return error; 
                }
            }
        }
           
        css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_ELEVATION, flags, value);

        if (((flags & FLAG_INHERIT as u8) == 0) && (value == ELEVATION_ANGLE )) {
            css_stylesheet::css__stylesheet_style_vappend(style, [length as u32, unit]);
        }
        //debug!("Exiting: css__parse_elevation (6)");
        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_font(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_font");
        let mut prev_ctx: uint;
        let mut token: &css_token;
        let mut bool_style = true;
        let mut variant = true;
        let mut weight = true;
        let mut line_height = true;
        let mut svw: int;
        let mut error: css_error;


        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        token=&vector[*ctx];

        if is_css_inherit(strings, lwc_ref, token) {
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_FONT_STYLE);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_FONT_VARIANT);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_FONT_WEIGHT);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_FONT_SIZE);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_LINE_HEIGHT);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_FONT_FAMILY);

            *ctx = *ctx + 1;
            return CSS_OK;
        }

        match sheet.font {
            None => {},
            Some(font_resolution) => {
                let (sheet_font_error , some_sys_font) = (*font_resolution)(token.idata.get_ref().clone());
                match token.token_type {
                    CSS_TOKEN_IDENT  => {
                        let value_from_font = match some_sys_font {
                            None => false,
                            _ => match sheet_font_error {
                                 CSS_OK => true,
                                 _ => false   
                            }
                        };
                        if value_from_font {
                            error  = parse_system_font(sheet , lwc_ref, strings , style , some_sys_font.unwrap());
                            match error {
                                CSS_OK => {
                                    *ctx = *ctx + 1;
                                    return error;
                                },
                                _=> {
                                    return error;
                                }
                            }
                        }
                    },
                    _ => {}
                }
            }
        }

        let style_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let variant_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let weight_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let size_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let line_height_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let family_style = css_stylesheet::css__stylesheet_style_create(sheet);

        svw = 0;
        while svw < 3 {
            prev_ctx = *ctx;

            if *ctx >= vector.len() {
               return CSS_INVALID;
            }
            token = &vector[*ctx];

            if is_css_inherit(strings, lwc_ref, token) {
                return CSS_INVALID;
            }

            let bool_error_style: bool = match css__parse_font_style(sheet , lwc_ref, strings , vector , ctx , style_style) {
                CSS_OK => true,
                _ => false
            };
            let bool_error_variant = match css__parse_font_variant(sheet , lwc_ref, strings , vector , ctx , variant_style) {
                CSS_OK => true,
                _ => false
            };
            let bool_error_weight = match css_properties::css__parse_font_weight(sheet , lwc_ref, strings , vector , ctx , weight_style) {
                CSS_OK => true,
                _ => false
            };

            if bool_style && bool_error_style {
                bool_style = false;
            }
            else if variant && bool_error_variant {
                variant = false;
            }
            else if weight && bool_error_weight {
                weight = false;
            }

            if bool_error_style||bool_error_variant||bool_error_weight {
                consumeWhitespace(vector , ctx);
            }
            else {
                break;
            }
            if *ctx == prev_ctx {
                break;
            }
            svw += 1;
        }

        consumeWhitespace(vector , ctx);

        if *ctx >= vector.len() {
           return CSS_INVALID;
        }
        token = &vector[*ctx];

        if is_css_inherit(strings, lwc_ref, token) {
            return CSS_INVALID;
        }

        error = css__parse_font_size(sheet , lwc_ref, strings , vector , ctx , size_style);
        match error {
            CSS_OK => {},
            _ => {
                return error;
            }
        }

        consumeWhitespace(vector , ctx);

        if *ctx >= vector.len() {
           return CSS_INVALID;
        }
        token = &vector[*ctx];

        if tokenIsChar(token, lwc_ref,  '/') {
            *ctx += 1;

            consumeWhitespace(vector , ctx);
            if *ctx >= vector.len() {
                return CSS_INVALID;
            }

            token = &vector[*ctx];
            if is_css_inherit(strings, lwc_ref, token) {
                return CSS_INVALID;
            }

            error = css__parse_line_height(sheet , lwc_ref, strings , vector , ctx , line_height_style);
            match error {
                CSS_OK => {},
                _ => {
                    return error;
                }
            }
            line_height = false;
        }

        consumeWhitespace(vector , ctx);

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        token = &vector[*ctx];

        if is_css_inherit(strings, lwc_ref, token) {
            return CSS_INVALID;
        }

        error = css_properties::css__parse_font_family(sheet , lwc_ref, strings , vector , ctx , family_style);
        match error {
            CSS_OK => {},
            _ => {
                return error;
            }
        }

        if bool_style {
            css_stylesheet::css__stylesheet_style_appendOPV(style_style , CSS_PROP_FONT_STYLE , 0 , FONT_STYLE_NORMAL );
        }
        if variant {
            css_stylesheet::css__stylesheet_style_appendOPV(variant_style , CSS_PROP_FONT_VARIANT , 0 , FONT_VARIANT_NORMAL );   
        }
        if weight {
            css_stylesheet::css__stylesheet_style_appendOPV(weight_style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_NORMAL );
        }
        if line_height {
            css_stylesheet::css__stylesheet_style_appendOPV(line_height_style , CSS_PROP_LINE_HEIGHT , 0 , LINE_HEIGHT_NORMAL );
        }
    
        
        css_stylesheet::css__stylesheet_merge_style(style , style_style);
        css_stylesheet::css__stylesheet_merge_style(style , variant_style);
        css_stylesheet::css__stylesheet_merge_style(style , weight_style);
        css_stylesheet::css__stylesheet_merge_style(style , size_style);
        css_stylesheet::css__stylesheet_merge_style(style , line_height_style);
        css_stylesheet::css__stylesheet_merge_style(style , family_style);
        
            
        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    pub fn css__parse_font_family(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings, vector:&~[css_token], ctx: @mut uint, result: @mut css_style) -> css_error {
    
        //debug!("Entering: css__parse_font_family");
        let orig_ctx = *ctx;
        
        /* [ IDENT+ | STRING ] [ ',' [ IDENT+ | STRING ] ]* | IDENT(inherit)
         * 
         * In the case of IDENT+, any whitespace between tokens is collapsed to
         * a single space
         *
         * \todo Mozilla makes the comma optional. 
         * Perhaps this is a quirk we should inherit?
         */

        if *ctx >= vector.len() {
            return CSS_INVALID
        }

        let token = &vector[*ctx];
        *ctx +=1; //Iterate
        
        if (token.token_type as int != CSS_TOKEN_IDENT as int)  && (token.token_type as int != CSS_TOKEN_STRING as int) {
            *ctx = orig_ctx;
            return CSS_INVALID
        }

        if (token.token_type as int == CSS_TOKEN_IDENT as int ) 
            && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), INHERIT as uint) {
            
            css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_FONT_FAMILY)
        } 
        else {
            *ctx = orig_ctx;
            //debug!(fmt!("css__parse_font_family :: *ctx (1) == %?" , *ctx));
            let error = css__comma_list_to_style(sheet , lwc_ref, strings , vector , ctx , Some(@font_family_reserved) , Some(@font_family_value) , result);
            //debug!(fmt!("css__parse_font_family :: *ctx (2) == %?" , *ctx));
            match error {
                CSS_OK => {},
                _ => {
                    *ctx = orig_ctx;
                    return error;
                }
            }

            css_stylesheet::css__stylesheet_style_append(result, FONT_FAMILY_END as u32);
        }

        CSS_OK
    }

 
    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_font_weight(_: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_font_weight");
        let orig_ctx = *ctx;
        let mut flags:u8 = 0;
        let mut value:u16= 0;
        let mut token: &css_token;

        if *ctx >= vector.len() {
            //debug!("Exiting: css__parse_font_weight (1)");
            return CSS_INVALID;
        }
        token=&vector[*ctx];
        *ctx += 1;

        if (token.token_type as int != CSS_TOKEN_IDENT as int && token.token_type as int != CSS_TOKEN_NUMBER as int) {
            *ctx = orig_ctx;
            //debug!("Exiting: css__parse_font_weight (2)");
            return CSS_INVALID
        }
        
        if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), INHERIT as uint) {
            flags |= FLAG_INHERIT as u8;
        }
        else if (token.token_type as int == CSS_TOKEN_NUMBER as int) {
            let (num,consumed) =  css__number_from_lwc_string(lwc_ref,token.idata.get_ref().clone(), true);

            if (consumed !=  lwc_ref.lwc_string_length(token.idata.get_ref().clone())){
                *ctx = orig_ctx;
                //debug!("Exiting: css__parse_font_weight (3)");
                return CSS_INVALID;
            }

            //debug!(fmt!("css__parse_font_weight:: num == %?", num));

            match (num >> 10) {
                100 => value = FONT_WEIGHT_100 ,
                200 => value = FONT_WEIGHT_200 ,
                300 => value = FONT_WEIGHT_300 ,
                400 => value = FONT_WEIGHT_400 ,
                500 => value = FONT_WEIGHT_500 ,
                600 => value = FONT_WEIGHT_600 ,
                700 => value = FONT_WEIGHT_700 ,
                800 => value = FONT_WEIGHT_800 ,
                900 => value = FONT_WEIGHT_900 ,
                _=>{
                    *ctx = orig_ctx;
                    //debug!("Exiting: css__parse_font_weight (4)");
                    return CSS_INVALID;
                }
            }
        }

        else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), NORMAL as uint) {
            value = FONT_WEIGHT_NORMAL ;
        }
        else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), BOLD as uint) {
            value = FONT_WEIGHT_BOLD ;
        }
        else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), BOLDER as uint) {
            value = FONT_WEIGHT_BOLDER ;
        }
        else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), LIGHTER as uint) {
            value = FONT_WEIGHT_LIGHTER ;
        }
        else  {
            *ctx = orig_ctx;
            //debug!("Exiting: css__parse_font_weight (5)");
            return CSS_INVALID;
        }
        css_stylesheet::css__stylesheet_style_appendOPV(style,  CSS_PROP_FONT_WEIGHT,flags, value);
        //debug!("Exiting: css__parse_font_weight (6)");
        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_list_style(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_list_style");
        let orig_ctx = *ctx;
        let mut token: &css_token;
        let mut image = true;
        let mut position = true;
        let mut type_type = true;
        let mut error: css_error= CSS_OK;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        token=&vector[*ctx];

        if is_css_inherit(strings, lwc_ref, token) {
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_LIST_STYLE_IMAGE);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_LIST_STYLE_POSITION);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_LIST_STYLE_TYPE);
            *ctx = *ctx + 1;
            return CSS_OK;
        }

        let image_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let position_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let type_style = css_stylesheet::css__stylesheet_style_create(sheet);

        let mut prev_ctx: uint;
        loop {
            prev_ctx = *ctx;
            if *ctx >= vector.len() {
                return CSS_INVALID;
            }
            
            token=&vector[*ctx];
            if is_css_inherit(strings, lwc_ref, token) {
                *ctx = orig_ctx;
                error = CSS_INVALID;
            }

            if ((type_type) && 
                (match (css_properties::css__parse_list_style_type(sheet , lwc_ref, strings , vector , ctx , type_style)) {
                    CSS_OK => true,
                    _ => false
                })) {
                type_type = false;
                error = CSS_OK;
            }
            
            else if (position) && 
                (match (css__parse_list_style_position(sheet , lwc_ref, strings , vector , ctx , position_style)) {
                    CSS_OK => true,
                    _ => false
                }) {
                position = false;
                error = CSS_OK;
            }
            else if (image) && 
                (match (css__parse_list_style_image(sheet , lwc_ref, strings , vector , ctx , image_style)) {
                    CSS_OK => true,
                    _ => false
                }) {
                image = false;
                error = CSS_OK;
            }
            match error {
                CSS_OK => {
                    consumeWhitespace(vector , ctx);
                    if *ctx >= vector.len() {
                        break;
                    }
                },
                _ => {
                    break;
                }
            }
            if *ctx == prev_ctx {
                break;
            }
        }

        if image {
            css_stylesheet::css__stylesheet_style_appendOPV(image_style , CSS_PROP_LIST_STYLE_IMAGE , 0 , LIST_STYLE_IMAGE_NONE );
        }
        if position {
            css_stylesheet::css__stylesheet_style_appendOPV(position_style , CSS_PROP_LIST_STYLE_POSITION , 0 , LIST_STYLE_POSITION_OUTSIDE );   
        }
        if type_type {
            css_stylesheet::css__stylesheet_style_appendOPV(type_style , CSS_PROP_LIST_STYLE_TYPE , 0 , LIST_STYLE_TYPE_DISC );
        }

        css_stylesheet::css__stylesheet_merge_style(style , image_style);
        css_stylesheet::css__stylesheet_merge_style(style , position_style);
        css_stylesheet::css__stylesheet_merge_style(style , type_style);

        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_list_style_type(_: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_list_style_type");
        let orig_ctx = *ctx;
        let mut token: &css_token;
        let mut flags: u8 = 0;
        let mut value : u16 = 0;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        token=&vector[*ctx];
        *ctx += 1;

        if token.token_type as int != CSS_TOKEN_IDENT as int{
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), INHERIT as uint) {
            flags |= FLAG_INHERIT as u8;
        }
        else {
            let (list_type , error) = css__parse_list_style_type_value(strings , lwc_ref, token);
            
            if error as int != CSS_OK as int {
                *ctx = orig_ctx;
                return error;
            }
            value = list_type.unwrap();
        }
        css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_LIST_STYLE_TYPE , flags , value);
        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_margin(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_margin");
        let orig_ctx = *ctx;
        let mut error: css_error;
        let mut token: &css_token;
        let mut side_val: ~[u16] = ~[];
        let mut side_length: ~[i32] = ~[];
        let mut side_unit: ~[u32] = ~[];
        let mut side_count: u32 = 0;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        token=&vector[*ctx];
        if is_css_inherit(strings, lwc_ref, token) {
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_MARGIN_TOP);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_MARGIN_RIGHT);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_MARGIN_BOTTOM);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_MARGIN_LEFT);
            *ctx += 1;
            return CSS_OK;
        }

        let mut prev_ctx: uint;
        loop {
            prev_ctx = *ctx;
            if is_css_inherit(strings, lwc_ref, token) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
            if (match token.token_type {
                CSS_TOKEN_IDENT  => true,
                _ => false
            }) && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), AUTO as uint) {

                side_val.push(MARGIN_AUTO);
                side_unit.push(0);
                side_length.push(0);
                *ctx = *ctx + 1;
                error = CSS_OK;
            }
            else {
                side_val.push(MARGIN_SET );
                let (length , unit , result) = css__parse_unit_specifier(sheet, lwc_ref, vector, ctx, UNIT_PX as u32);
                error = result ;
                if length.is_some() {
                    side_length.push(length.unwrap());
                }
                else {
                    side_length.push(0);
                }

                if unit.is_some() {
                    side_unit.push(unit.unwrap());
                } 
                else {
                    side_unit.push(0);
                }

                match result {
                    CSS_OK => {
                        if (side_unit[side_count] & (UNIT_ANGLE as u32)) > 0 {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                        if (side_unit[side_count] & (UNIT_TIME as u32)) > 0{
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                        if (side_unit[side_count] & (UNIT_FREQ as u32)) > 0{
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                    },
                    _ => {}
                }
            }
            match error {
                CSS_OK => {
                    side_count += 1;
                    consumeWhitespace(vector , ctx);
                    if *ctx >= vector.len() {
                        break;
                    }
                    token=&vector[*ctx];
                }
                _ => {
                    break
                }
            }
            if !(*ctx != prev_ctx && side_count < 4) {
                break;
            }
        }
        match side_count {
            1 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_TOP , 0 , side_val[0]);

                if side_val[0] == MARGIN_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                }
                
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_RIGHT , 0 , side_val[0]);
                
                if side_val[0] == MARGIN_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_BOTTOM , 0 , side_val[0]);
                
                if side_val[0] == MARGIN_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_LEFT , 0 , side_val[0]);
                
                if side_val[0] == MARGIN_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                }

            },
            2 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_TOP , 0 , side_val[0]);
                
                if side_val[0] == MARGIN_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_RIGHT , 0 , side_val[1]);
                
                if side_val[1] == MARGIN_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_BOTTOM , 0 , side_val[0]);
                
                if side_val[0] == MARGIN_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_LEFT , 0 , side_val[1]);
                
                if side_val[1] == MARGIN_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                }

            },
            3 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_TOP , 0 , side_val[0]);
                
                if side_val[0] == MARGIN_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_RIGHT , 0 , side_val[1]);
                
                if side_val[1] == MARGIN_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_BOTTOM , 0 , side_val[2]);
                
                if side_val[2] == MARGIN_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[2] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[2] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_LEFT , 0 , side_val[1]);
                
                if side_val[1] == MARGIN_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                }

            },
            4 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_TOP , 0 , side_val[0]);
                
                if side_val[0] == MARGIN_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_RIGHT , 0 , side_val[1]);
                
                if side_val[1] == MARGIN_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_BOTTOM , 0 , side_val[2]);
                
                if side_val[2] == MARGIN_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[2] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[2] as u32);
                }

                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_MARGIN_LEFT , 0 , side_val[3]);
                
                if side_val[3] == MARGIN_SET {
                    css_stylesheet::css__stylesheet_style_append(style , side_length[3] as u32);
                    css_stylesheet::css__stylesheet_style_append(style , side_unit[3] as u32);
                }

            },
            _ => {
                *ctx = orig_ctx;
            }
        }
        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_opacity(_: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_opacity");
        let orig_ctx:uint = *ctx;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }

        let token=&vector[*ctx];
        *ctx += 1;
        
        match token.token_type {
            CSS_TOKEN_IDENT =>{
                if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), INHERIT as uint) {
                    css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_OPACITY);
                }
            },
            CSS_TOKEN_NUMBER=>{
                    					
					let (num_,consumed) =  css__number_from_lwc_string(lwc_ref,token.idata.get_ref().clone(), false);
                    let mut num = num_;
                    /* Invalid if there are trailing characters */
                    if (consumed !=  lwc_ref.lwc_string_length(token.idata.get_ref().clone())){
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }

                    // /* Clamp to range [0,1] */
                    if num < 0 {
                        num = 0;
                    }
                    if num > css_int_to_fixed(1) {
                        num = css_int_to_fixed(1);
                    }

                    css_stylesheet::css__stylesheet_style_appendOPV(style, CSS_PROP_OPACITY, 0, OPACITY_SET );
                    css_stylesheet::css__stylesheet_style_append(style, num as u32);
            },
            _=>{
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        CSS_OK
    }

    
    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_outline(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
       
        //debug!("Entering: css__parse_outline");
        let orig_ctx = *ctx;
        let mut token: &css_token;
        let mut color =true;
        let mut style_bool =true;
        let mut width =true;
        let mut error: css_error = CSS_OK;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        token=&vector[*ctx];
        if (is_css_inherit(strings, lwc_ref, token)) {
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_OUTLINE_COLOR);
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_OUTLINE_STYLE);
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_OUTLINE_WIDTH);
            *ctx +=1;
            return CSS_OK;
        }
        
        let color_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let style_style = css_stylesheet::css__stylesheet_style_create(sheet);
        let width_style = css_stylesheet::css__stylesheet_style_create(sheet);

        let mut prev_ctx: uint;

        loop {
            prev_ctx = *ctx;
            
            if *ctx >= vector.len() {
                return CSS_INVALID;
            }

            token=&vector[*ctx];
            
            if is_css_inherit(strings, lwc_ref, token) {
                *ctx = orig_ctx;
                error = CSS_INVALID;
            }

            if ((color) && 
                (match (css__parse_outline_color(sheet , lwc_ref, strings , vector , ctx , color_style)) {
                    CSS_OK => true,
                    _ => false
                })) {
                color = false;
                error = CSS_OK;
            }
            
            else if (style_bool) && 
                (match (css__parse_outline_style(sheet , lwc_ref, strings , vector , ctx , style_style)) {
                    CSS_OK => true,
                    _ => false
                }) {
                style_bool = false;
                error = CSS_OK; 
            }
            else if (width) && 
                (match (css__parse_outline_width(sheet , lwc_ref, strings , vector , ctx , width_style)) {
                    CSS_OK => true,
                    _ => false
                }) {
                width = false;
                error = CSS_OK;
            }
            match error {
                CSS_OK => {
                    consumeWhitespace(vector , ctx);
                    if *ctx >= vector.len() {
                        break;
                    }
                },
                _ => {
                    break;
                }
            }
            if *ctx == prev_ctx {
                break;
            }
        }
        if color {
            css_stylesheet::css__stylesheet_style_appendOPV(color_style , CSS_PROP_OUTLINE_COLOR , 0 , OUTLINE_COLOR_INVERT );
        }
        if style_bool {
            css_stylesheet::css__stylesheet_style_appendOPV(style_style , CSS_PROP_OUTLINE_STYLE , 0 , OUTLINE_STYLE_NONE );   
        }
        if width {
            css_stylesheet::css__stylesheet_style_appendOPV(width_style , CSS_PROP_OUTLINE_WIDTH , 0 , OUTLINE_WIDTH_MEDIUM );
        }

        css_stylesheet::css__stylesheet_merge_style(style , color_style);
        css_stylesheet::css__stylesheet_merge_style(style , style_style);
        css_stylesheet::css__stylesheet_merge_style(style , width_style);

        CSS_OK
    }

    
    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_padding(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_padding");
        let orig_ctx = *ctx;
        let mut side_length: ~[i32] = ~[];
        let mut side_unit: ~[u32] = ~[];
        let mut side_count: u32 = 0;
        let mut token: &css_token;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        token=&vector[*ctx];
        if is_css_inherit(strings, lwc_ref, token) {
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_PADDING_TOP);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_PADDING_RIGHT);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_PADDING_BOTTOM);
            css_stylesheet::css_stylesheet_style_inherit(style , CSS_PROP_PADDING_LEFT);
            *ctx = *ctx + 1;
            return CSS_OK;
        }

        let mut prev_ctx: uint;
        loop {
            prev_ctx = *ctx;
            if is_css_inherit(strings, lwc_ref, token) {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }

            let (length_val , unit_val , result) = css__parse_unit_specifier(sheet, lwc_ref, vector, ctx, UNIT_PX as u32);
            match result {
                CSS_OK => {
                    side_length.push(length_val.unwrap() as i32);
                    side_unit.push(unit_val.unwrap());
                    if (side_unit[side_count] & (UNIT_ANGLE as u32)) > 0 {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    if (side_unit[side_count] & (UNIT_TIME as u32)) > 0{
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    if (side_unit[side_count] & (UNIT_FREQ as u32)) > 0{
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    if side_unit[side_count] < 0 {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                    side_count += 1;
                    consumeWhitespace(vector , ctx);
                    if *ctx >= vector.len() {
                        break;
                    }
                },
                _ => {
                    break;
                }
            }
            if !(*ctx != prev_ctx && side_count < 4) {
                break;
            }
        }
        match side_count {
            1 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_TOP , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_RIGHT , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_BOTTOM , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_LEFT , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
            },
            2 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_TOP , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_RIGHT , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_BOTTOM , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_LEFT , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
            },
            3 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_TOP , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_RIGHT , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_BOTTOM , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[2] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[2] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_LEFT , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
            },
            4 => {
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_TOP , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[0] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[0] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_RIGHT , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[1] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[1] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_BOTTOM , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[2] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[2] as u32);
                css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_PADDING_LEFT , 0 , PADDING_SET );
                css_stylesheet::css__stylesheet_style_append(style , side_length[3] as u32);
                css_stylesheet::css__stylesheet_style_append(style , side_unit[3] as u32);
            },
            _ => {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_pause(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_pause");
        let orig_ctx = *ctx;
        let first_token: &css_token;
        let token: &css_token;

        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        
        first_token = &vector[*ctx];
        
        let mut error = css__parse_pause_before(sheet, lwc_ref, strings, vector, ctx, style);
        
        match error {
            CSS_OK=> {
                
                consumeWhitespace(vector, ctx);
                
                if (*ctx >= vector.len() )  {
                    //debug!("Entering: css__parse_pause  :: no second token, re-parse the first");
                    /* no second token, re-parse the first */
                    *ctx = orig_ctx;
                    error =  css__parse_pause_after(sheet, lwc_ref, strings, vector, ctx, style);
                } 
                else {
                    token = &vector[*ctx];

                    //debug!("css__parse_pause:: token == %?" , token);

                    /* second token - might be useful */
                    if ( is_css_inherit(strings, lwc_ref,  token)) {
                        /* another bogus inherit */
                        error = CSS_INVALID;
                        //debug!("css__parse_pause ::  after is_css_inherit(1)");
                    } 
                    else {
                        error =  css__parse_pause_after(sheet, lwc_ref, strings, vector, ctx, style);
                        match (error) {
                            CSS_OK => { 
                                //debug!("css__parse_pause ::  second token parsed");
                                /* second token parsed */
                                if ( is_css_inherit(strings, lwc_ref,  first_token)) {
                                    /* valid second token after inherit */
                                    error = CSS_INVALID;
                                    //debug!("css__parse_pause ::  after is_css_inherit(2)");
                                }
                            },
                            _=> {
                                //debug!("css__parse_pause ::  second token appears to be junk re-try with first");
                                /* second token appears to be junk re-try with first */
                                *ctx = orig_ctx;
                                error =  css__parse_pause_after(sheet, lwc_ref, strings, vector, ctx, style);
                            }
                        }
                    }
                }
            },
            _=>{
                *ctx = orig_ctx;
            }
        }
        //debug!("css__parse_pause error == %?", error );
       return error;
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_play_during(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_play_during");
        let orig_ctx = *ctx;
        let mut token: &css_token;
        let mut flags: u8 = 0;
        let mut value: u16 = 0;
        let mut uri_snumber: u32 = 0;


        if *ctx >= vector.len() {
            return CSS_INVALID;
        }
        token=&vector[*ctx];
        *ctx += 1;

        if (token.token_type as int != CSS_TOKEN_IDENT as int) && (token.token_type as int != CSS_TOKEN_URI as int) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (token.token_type as int == CSS_TOKEN_IDENT as int) {
            if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), INHERIT as uint) {
                flags = flags | FLAG_INHERIT as u8;
            }
            else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), NONE as uint) {
                value = PLAY_DURING_NONE as u16;
            }
            else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), AUTO as uint) {
                value = PLAY_DURING_AUTO as u16;
            }
            else {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }
        else {
            let mut modifiers:int = 0;
            value = PLAY_DURING_URI as u16;
            let uri:uint;
            match (*sheet.resolve)( sheet.url, token.idata.get_ref().clone()) {
                (CSS_OK, Some(x)) => {
                    uri =x;
                },
                (error,_) => {
                    *ctx = orig_ctx;
                    return error;
                }
            }
            uri_snumber = sheet.css__stylesheet_string_add(uri) as u32;

            while modifiers < 2 {
                consumeWhitespace(vector, ctx);

                let mut token_null = false;

                if *ctx >= vector.len() {
                    token_null = true;
                } 
                else {
                    token=&vector[*ctx];
                }

                

                if !token_null && token.token_type as int == CSS_TOKEN_IDENT as int {
                    if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), MIX as uint) {
                        if (value & (PLAY_DURING_MIX as u16)) == 0 {
                            value |= (PLAY_DURING_MIX as u16);
                        }
                        else {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                    }
                    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), REPEAT as uint) {
                        if (value & (PLAY_DURING_REPEAT as u16)) == 0 {
                            value |= (PLAY_DURING_REPEAT as u16);
                        }
                        else {
                            *ctx = orig_ctx;
                            return CSS_INVALID;
                        }
                    }
                    else {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }

                    *ctx = *ctx + 1;
                }
                
                modifiers += 1;
            }
        }
        css_stylesheet::css__stylesheet_style_appendOPV(style ,CSS_PROP_PLAY_DURING , flags , value);

        if ((flags & FLAG_INHERIT as u8)==0 && (value & PLAY_DURING_TYPE_MASK as u16)==PLAY_DURING_URI as u16) {
            css_stylesheet::css__stylesheet_style_append(style , uri_snumber);
        }
        CSS_OK
    }

    
    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_quotes(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
            
        //debug!("Entering: css__parse_quotes");
        let orig_ctx:uint = *ctx;
        if *ctx >= vector.len() {
            return CSS_INVALID;
        }

        let mut token = &vector[*ctx];
        *ctx += 1;

        if (token.token_type as int != CSS_TOKEN_IDENT as int) && (token.token_type as int != CSS_TOKEN_STRING as int ) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        if (token.token_type as int == CSS_TOKEN_IDENT as int) && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), INHERIT as uint) {
            css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_QUOTES);
        }
        else if (token.token_type as int == CSS_TOKEN_IDENT as int) && strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), NONE as uint) {
            css_stylesheet::css__stylesheet_style_appendOPV(style,CSS_PROP_QUOTES, 0, QUOTES_NONE );
        }
        else if (token.token_type as int == CSS_TOKEN_STRING as int){
            let mut first: bool =true;
            let token_null = false;
            
            while !token_null && token.token_type as int == CSS_TOKEN_STRING as int {

                let open_snumber:u32;
                let close_snumber:u32;
                open_snumber = sheet.css__stylesheet_string_add(token.idata.unwrap()) as u32;
                consumeWhitespace(vector, ctx);
                
                if (*ctx >= vector.len()) {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                } 

                token=&vector[*ctx];
                *ctx += 1;
                match token.token_type {
                    CSS_TOKEN_STRING  => {},
                    _=> {
                        *ctx = orig_ctx;
                        return CSS_INVALID;
                    }
                }
                close_snumber = sheet.css__stylesheet_string_add(token.idata.unwrap()) as u32;
                consumeWhitespace(vector, ctx); 
                match first {
                    true => css_stylesheet::css__stylesheet_style_append(style,buildOPV(CSS_PROP_QUOTES, 0, QUOTES_STRING)),
                    false=> css_stylesheet::css__stylesheet_style_append(style, QUOTES_STRING as u32)
                }
                
                css_stylesheet::css__stylesheet_style_append(style, open_snumber);
                css_stylesheet::css__stylesheet_style_append(style, close_snumber);

                first =false;
                if (*ctx >= vector.len()) {
                    break;
                }
                token=&vector[*ctx];
                match token.token_type {
                    CSS_TOKEN_STRING  => {},
                    _=> {
                        break;
                    }
                }
                if (*ctx >= vector.len()) {
                    break;
                } 
                token=&vector[*ctx];
                *ctx += 1;
            }
            css_stylesheet::css__stylesheet_style_append(style, QUOTES_NONE as u32);
        }
        else {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }
        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_text_decoration(_: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings ,vector:&~[css_token], ctx: @mut uint, style: @mut css_style)->css_error {
        
        //debug!("Entering: css__parse_text_decoration");
        let orig_ctx:uint= *ctx;
        let mut token: &css_token;

        if *ctx >= vector.len() {
            //debug!("Exiting: css__parse_text_decoration (1)");
            return CSS_INVALID;
        }
        token=&vector[*ctx];
        *ctx += 1;

        match token.token_type {
            CSS_TOKEN_IDENT  => {
                if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), INHERIT as uint) {
                    css_stylesheet::css_stylesheet_style_inherit(style, CSS_PROP_TEXT_DECORATION);
                }
                else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), NONE as uint)  {
                    css_stylesheet::css__stylesheet_style_appendOPV(style,CSS_PROP_TEXT_DECORATION, 0, TEXT_DECORATION_NONE );
                }
                else {
                    let mut value: u16 = 0 ;
                    loop {
                        if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), UNDERLINE as uint) {
                            if ((value & TEXT_DECORATION_UNDERLINE ) == 0) {
                                value |= TEXT_DECORATION_UNDERLINE ;
                            }
                            
                            else {
                                *ctx = orig_ctx;
                                //debug!("Exiting: css__parse_text_decoration (2)");
                                return CSS_INVALID;
                            }
                        }
                        else if  strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), OVERLINE as uint) {
                            if ((value & TEXT_DECORATION_OVERLINE ) == 0) {
                                value |= TEXT_DECORATION_OVERLINE ;
                            }
                            else {
                                *ctx = orig_ctx;
                                //debug!("Exiting: css__parse_text_decoration (3)");
                                return CSS_INVALID;
                            }
                        }
                        else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), LINE_THROUGH as uint) {
                            if ((value & TEXT_DECORATION_LINE_THROUGH ) == 0) {
                                value |= TEXT_DECORATION_LINE_THROUGH ;
                            }
                            else {
                                *ctx = orig_ctx;
                                //debug!("Exiting: css__parse_text_decoration (4)");
                                return CSS_INVALID;

                            }
                        }
                        else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), BLINK as uint) {
                            if ((value & (TEXT_DECORATION_BLINK )) == 0) {
                                value |= TEXT_DECORATION_BLINK ;
                            }
                            else {
                                *ctx = orig_ctx;
                                //debug!("Exiting: css__parse_text_decoration (5)");
                                return CSS_INVALID;
                            }
                        }
                        else {
                            *ctx = orig_ctx;
                            //debug!("Exiting: css__parse_text_decoration (6)");
                            return CSS_INVALID;
                        }
                        consumeWhitespace(vector, ctx);
                        
                        if *ctx >= vector.len() {
                            break;
                        }
                        token=&vector[*ctx];

                        match (token.token_type) {
                            CSS_TOKEN_IDENT  => {},
                            _=> {
                                break;
                            }
                        }

                        *ctx += 1;
                    }

                    css_stylesheet::css__stylesheet_style_appendOPV(style,  CSS_PROP_TEXT_DECORATION, 0, value);
                }
            },
            _=> {
                *ctx = orig_ctx;
                //debug!("Exiting: css__parse_text_decoration (7)");
                return CSS_INVALID;
            }
        }
        //debug!("Exiting: css__parse_text_decoration (8)");
        CSS_OK
    }


    /**
    * #Arguments:
    *  'sheet'  - Stylesheet. 

    *  'strings' -  Prop_string

    *  'vector' - Vector of tokens to process.

    *  'ctx'    - Pointer to vector iteration ctx.

    *  'results' -  css_style

    * #Return Value:
    * 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

    * #Post condition:
    *   ctx is updated with the next token to process.
    *   If the input is invalid, then ctx remains unchanged.
    */
    fn css__parse_voice_family(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings, vector:&~[css_token], ctx: @mut uint, result: @mut css_style) -> css_error {
    
        //debug!("Entering: css__parse_voice_family");
        let orig_ctx = *ctx;
		//debug!(fmt!("ctx == %?", *ctx));
        /* [ IDENT+ | STRING ] [ ',' [ IDENT+ | STRING ] ]* | IDENT(inherit)
         * 
         * In the case of IDENT+, any whitespace between tokens is collapsed to
         * a single space
         */
        if *ctx >= vector.len() {
            return CSS_INVALID
        }


        let token = &vector[*ctx];
        *ctx += 1;

        match token.token_type {
            CSS_TOKEN_IDENT  | CSS_TOKEN_STRING  => {}, 
            _ => {
                *ctx = orig_ctx;
                return CSS_INVALID
            }
        } 

        if match token.token_type { CSS_TOKEN_IDENT  => true, _ => false } &&
                strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), INHERIT as uint) {
            
            css_stylesheet::css_stylesheet_style_inherit(result, CSS_PROP_VOICE_FAMILY)
        } 
        else {
            *ctx = orig_ctx;
            let error = css__comma_list_to_style(sheet , lwc_ref, strings , vector , ctx , Some(@voice_family_reserved) , Some(@voice_family_value) , result);
            match error {
                CSS_OK => {},
                _ => {
                    *ctx = orig_ctx;
                    return error;
                }
            }
            css_stylesheet::css__stylesheet_style_append(result, VOICE_FAMILY_END as u32);
        }
		//debug!(fmt!("ctx == %?", *ctx));
        CSS_OK
    }
      
}//end of impl css_properties

/**
* #Arguments:
*  'strings' -  css_propstrings

*  'token' - tokens to process.

* #Return Value:
* 'value' - Option of u16 (Some(x) if CSS_OK else None)

* 'css_error' - CSS_OK on success,  
                    CSS_INVALID if the input is not valid.

* #Post condition:
*   ctx is updated with the next token to process.
*   If the input is invalid, then ctx remains unchanged.
*/
pub fn css__parse_list_style_type_value(strings: &css_propstrings , lwc_ref:&mut ~lwc, token: &css_token) -> (Option<u16> , css_error) {
    
    //debug!("Entering: css__parse_list_style_type_value");
    if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), DISC as uint) {
        return (Some(LIST_STYLE_TYPE_DISC ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), CIRCLE as uint) {
        return (Some(LIST_STYLE_TYPE_CIRCLE ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), SQUARE as uint) {
        return (Some(LIST_STYLE_TYPE_SQUARE ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), DECIMAL as uint) {
        return (Some(LIST_STYLE_TYPE_DECIMAL ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), DECIMAL_LEADING_ZERO as uint) {
        return (Some(LIST_STYLE_TYPE_DECIMAL_LEADING_ZERO ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), LOWER_ROMAN as uint) {
        return (Some(LIST_STYLE_TYPE_LOWER_ROMAN ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), UPPER_ROMAN as uint) {
        return (Some(LIST_STYLE_TYPE_UPPER_ROMAN ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), LOWER_GREEK as uint) {
        return (Some(LIST_STYLE_TYPE_LOWER_GREEK ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), LOWER_LATIN as uint) {
        return (Some(LIST_STYLE_TYPE_LOWER_LATIN ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), UPPER_LATIN as uint) {
        return (Some(LIST_STYLE_TYPE_UPPER_LATIN ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), ARMENIAN as uint) {
        return (Some(LIST_STYLE_TYPE_ARMENIAN ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), GEORGIAN as uint) {
        return (Some(LIST_STYLE_TYPE_GEORGIAN ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), LOWER_ALPHA as uint) {
        return (Some(LIST_STYLE_TYPE_LOWER_ALPHA ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), UPPER_ALPHA as uint) {
        return (Some(LIST_STYLE_TYPE_UPPER_ALPHA ) , CSS_OK);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), NONE as uint) {
        return (Some(LIST_STYLE_TYPE_NONE ) , CSS_OK);
    }
    else {
        return (None , CSS_INVALID);
    }
}


/**
* #Arguments:
*  'strings' -  css_propstrings

*  'ident' - IDENT to consider.

* #Return Value:
*   True if IDENT is reserved, false otherwise.
*/
pub fn font_family_reserved(strings:&css_propstrings,  lwc_ref:&mut ~lwc, ident: &css_token) -> bool {

    //debug!("Entering: font_family_reserved");
    strings.lwc_string_caseless_isequal(lwc_ref, ident.idata.get_ref().clone(), SERIF as uint) ||
    strings.lwc_string_caseless_isequal(lwc_ref, ident.idata.get_ref().clone(), SANS_SERIF as uint) ||
    strings.lwc_string_caseless_isequal(lwc_ref, ident.idata.get_ref().clone(), CURSIVE as uint) ||
    strings.lwc_string_caseless_isequal(lwc_ref, ident.idata.get_ref().clone(), FANTASY as uint) ||
    strings.lwc_string_caseless_isequal(lwc_ref, ident.idata.get_ref().clone(), MONOSPACE as uint)
}


/**
* #Arguments:
*  'strings' -  Propstrings

*  'token' - Token to consider.

*  'first' - Whether the token is the first.

* #Return Value:
*   Bytecode value.
*/
pub fn font_family_value(strings:&css_propstrings, lwc_ref:&mut ~lwc, token: &css_token, first:bool) -> u32 {
    
    //debug!("Entering: font_family_value");
    let value:u16;
    
    match token.token_type{
        CSS_TOKEN_IDENT  => {
            if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), SERIF as uint) {
                value = FONT_FAMILY_SERIF
            }    
            else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), SANS_SERIF as uint) {
                value = FONT_FAMILY_SANS_SERIF 
            }    
            else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), CURSIVE as uint) {
                value = FONT_FAMILY_CURSIVE
            }    
            else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), FANTASY as uint) {
                value = FONT_FAMILY_FANTASY
            }    
            else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), MONOSPACE as uint) {
                value = FONT_FAMILY_MONOSPACE
            }    
            else {
                value = FONT_FAMILY_IDENT_LIST 
            }    
        },
        _ =>  value = FONT_FAMILY_STRING 
    } 
    
    if first {
      buildOPV(CSS_PROP_FONT_FAMILY, 0, value )  as u32
    }
    else{
        value as u32
    }  
}


/**
* #Arguments:
*  'sheet' - css_stylesheet.
*  'strings' -  css_propstrings.
*  'style' - css_style.
*  'system_font' - css_system_font.
* #Return Value:
*   'css_error'.
*/
pub fn parse_system_font(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings:&css_propstrings , style: @mut css_style , system_font: css_system_font) -> css_error{
    
    //debug!("Entering: parse_system_font");
    match system_font.style {
        CSS_FONT_STYLE_NORMAL => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_STYLE , 0 , FONT_STYLE_NORMAL );
        },
        CSS_FONT_STYLE_ITALIC => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_STYLE , 0 , FONT_STYLE_ITALIC );  
        },
        CSS_FONT_STYLE_OBLIQUE => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_STYLE , 0 , FONT_STYLE_OBLIQUE );  
        },
        _ => {
            return CSS_BADPARM;
        }
    }

    match system_font.variant {
        CSS_FONT_VARIANT_NORMAL => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_VARIANT , 0 , FONT_VARIANT_NORMAL );
        },
        CSS_FONT_VARIANT_SMALL_CAPS => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_VARIANT , 0 , FONT_VARIANT_SMALL_CAPS );  
        },
        _ => {
            return CSS_BADPARM;
        }
    }

    match system_font.weight {
        CSS_FONT_WEIGHT_NORMAL => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_NORMAL );
        },
        CSS_FONT_WEIGHT_BOLD => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_BOLD );  
        },
        CSS_FONT_WEIGHT_BOLDER => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_BOLDER );  
        },
        CSS_FONT_WEIGHT_LIGHTER => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_LIGHTER );  
        },
        CSS_FONT_WEIGHT_100 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_100 );  
        },
        CSS_FONT_WEIGHT_200 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_200 );  
        },
        CSS_FONT_WEIGHT_300 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_300 );  
        },
        CSS_FONT_WEIGHT_400 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_400 );  
        },
        CSS_FONT_WEIGHT_500 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_500 );  
        },
        CSS_FONT_WEIGHT_600 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_600 );  
        },
        CSS_FONT_WEIGHT_700 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_700 );  
        },
        CSS_FONT_WEIGHT_800 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_800 );  
        },
        CSS_FONT_WEIGHT_900 => {
            css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_WEIGHT , 0 , FONT_WEIGHT_900 );  
        },
        _ => {
            return CSS_BADPARM;
        }
    }

    css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_SIZE , 0 , FONT_SIZE_DIMENSION as u16);
    css_stylesheet::css__stylesheet_style_vappend(style , [system_font.size.size as u32 , system_font.size.unit as u32]);
    css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_LINE_HEIGHT , 0 , LINE_HEIGHT_DIMENSION as u16);
    css_stylesheet::css__stylesheet_style_vappend(style , [system_font.line_height.size as u32 , system_font.line_height.unit as u32]);

    if strings.lwc_string_caseless_isequal(lwc_ref, system_font.family , SERIF as uint) {
        css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_FAMILY , 0 , FONT_FAMILY_SERIF as u16);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, system_font.family , SANS_SERIF as uint) {
        css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_FAMILY , 0 , FONT_FAMILY_SANS_SERIF as u16);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, system_font.family , CURSIVE as uint) {
        css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_FAMILY , 0 , FONT_FAMILY_CURSIVE as u16);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, system_font.family , FANTASY as uint) {
        css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_FAMILY , 0 , FONT_FAMILY_FANTASY as u16);
    }
    else if strings.lwc_string_caseless_isequal(lwc_ref, system_font.family , MONOSPACE as uint) {
        css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_FAMILY , 0 , FONT_FAMILY_MONOSPACE as u16);
    }
    else {
        let sNumber: u32;
        sNumber = sheet.css__stylesheet_string_add(system_font.family) as u32;

        css_stylesheet::css__stylesheet_style_appendOPV(style , CSS_PROP_FONT_FAMILY , 0 , FONT_FAMILY_STRING as u16);           
        css_stylesheet::css__stylesheet_style_append(style , sNumber);
    }
    css_stylesheet::css__stylesheet_style_append(style , FONT_FAMILY_END as u32);

    CSS_INVALID
}

/**
* #Arguments:
*  'strings' -  css_propstrings.

*  'ident' - IDENT to consider.

*  'system_font' - css_system_font.

* #Return Value:
*   'bool' - True if IDENT is reserved, false otherwise.
*/
pub fn voice_family_reserved(strings: &css_propstrings,  lwc_ref:&mut ~lwc, ident: &css_token) -> bool {
    
    //debug!("Entering: voice_family_reserved");
    strings.lwc_string_caseless_isequal(lwc_ref, ident.idata.get_ref().clone(), MALE as uint) ||
    strings.lwc_string_caseless_isequal(lwc_ref, ident.idata.get_ref().clone(), FEMALE as uint) ||
    strings.lwc_string_caseless_isequal(lwc_ref, ident.idata.get_ref().clone(), CHILD as uint) 
}

/**
* #Arguments:
*  'strings' -  css_propstrings.

*  'token' - token to consider.

*  'system_font' - css_system_font.

* #Return Value:
*   'u32' - Bytecode value.
*/
pub fn voice_family_value(strings: &css_propstrings, lwc_ref:&mut ~lwc,  token: &css_token, first:bool) -> u32
{
    //debug!("Entering: voice_family_value");
    let value = match token.token_type {
        CSS_TOKEN_IDENT  => {
            if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), MALE as uint){
                VOICE_FAMILY_MALE
            }
            else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), FEMALE as uint){
                VOICE_FAMILY_FEMALE   
            }
            else if strings.lwc_string_caseless_isequal(lwc_ref, token.idata.get_ref().clone(), CHILD as uint){
                VOICE_FAMILY_CHILD
            }
            else{
                VOICE_FAMILY_IDENT_LIST
            }
        },
        _ => VOICE_FAMILY_STRING     
    }; 
   
    if first {
        buildOPV(CSS_PROP_VOICE_FAMILY, 0, value ) 
    }
    else {
        value as u32  
    }   
}

/**
* #Arguments:
*  'sheet' -  Stylesheet.

*  'strings' -  css_propstrings.

*  'vector' - Vector of tokens to process.

*  'ctx' - Pointer to vector iteration ctx.

*  'reserved' - 

* #Return Value:
*   'result' - Option of ~str (Some(x) if CSS_OK else None).
*   'css_error' - CSS_OK on success, 
            CSS_INVALID if the input is not valid

* #Post Condition:
*   ctx is updated with the next token to process
        If the input is invalid, then \a ctx remains unchanged.
*/
pub fn css__ident_list_or_string_to_string(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings, vector:&~[css_token], ctx:@mut uint, reserved:Option<reserved_fn>)
    -> (css_error, Option<~str>) {
    
    //debug!("Entering: css__ident_list_or_string_to_string");
    if *ctx >= vector.len() {
        return (CSS_INVALID,None)
    }
    
    let mut token = &vector[*ctx];  
    
    match token.token_type {
        CSS_TOKEN_STRING  => {
            token = &vector[*ctx];
            *ctx += 1; //Iterate
            return (CSS_OK,Some(lwc_ref.lwc_string_data(token.idata.get_ref().clone())))
        },  
        CSS_TOKEN_IDENT  =>  return css__ident_list_to_string(sheet , lwc_ref, strings , vector , ctx , reserved),
        _ => return (CSS_INVALID,None)
    }
}

/**
* #Arguments:
*  'strings' -  css_propstrings.

*  'vector' - Vector of tokens to process.

*  'ctx' - Pointer to vector iteration ctx.

*  'reserved' - Callback to determine if an identifier is reserved.

* #Return Value:
*   'result' - Option of ~str (Some(x) if CSS_OK else None).
*   'css_error' - CSS_OK on success, 
            CSS_INVALID if the input is not valid

* #Post Condition:
*   ctx is updated with the next token to process
        If the input is invalid, then \a ctx remains unchanged.
*/

pub fn css__ident_list_to_string(_: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings, vector:&~[css_token],
    ctx: @mut uint , reserved:Option<reserved_fn>) -> (css_error , Option<~str>) {

    //debug!("Entering: css__ident_list_to_string");
    let orig_ctx = *ctx;
    let mut token: &css_token;
    let mut token_buffer_string: ~str = ~"";

    /* We know this token exists, and is an IDENT */
	//Iterate
	if *ctx >= vector.len() {
		*ctx +=1;
        return (CSS_INVALID , None);
    }

    token = &vector[*ctx];
    *ctx += 1;
	
	/* Consume all subsequent IDENT or S tokens */
    loop {
        match token.token_type {
            /* IDENT -- if reserved, reject style */
			CSS_TOKEN_IDENT  => {
                match reserved {
                    None => {},
                    Some(reserved_function) => {
                        if (*reserved_function)(strings , lwc_ref, token) {
                            *ctx = orig_ctx;
                            return (CSS_INVALID , None);
                        }
                    }
                }
                token_buffer_string.push_str(lwc_ref.lwc_string_data(token.idata.get_ref().clone()));
            },
            CSS_TOKEN_S => {
				/* S */
                token_buffer_string.push_str(" ");
            },
            _ => {
                break;
            }
        }
        if *ctx >= vector.len() {
            *ctx+=1;
			break;
        }
		else{
			token = &vector[*ctx];
			*ctx += 1;
		}	
    }
	
	/* Rewind context by one step if we consumed an unacceptable token */
    if *ctx < vector.len() {
        *ctx -= 1;
    }
	
    /* Strip trailing whitespace */

    return (CSS_OK , Some(token_buffer_string.trim_right().to_owned()));
}


/**
* #Arguments:
*  'sheet' -  Stylesheet.

*  'strings' -  css_propstrings.

*  'vector' - Vector of tokens to process.

*  'ctx' - Pointer to vector iteration ctx.

*  'reserved' - 

*  'get_value' - Callback to retrieve bytecode value for a token.

*  'style' - 

* #Return Value:
*   'css_error' - CSS_OK on success, 
            CSS_INVALID if the input is not valid

* #Post Condition:
*   ctx is updated with the next token to process
        If the input is invalid, then \a ctx remains unchanged.
*/
pub fn css__comma_list_to_style(sheet: @mut css_stylesheet , lwc_ref:&mut ~lwc, strings: &css_propstrings, vector:&~[css_token], 
    ctx: @mut uint , reserved:Option<reserved_fn> , get_value: Option<get_value_fn> , style: @mut css_style) -> css_error {

    //debug!("Entering: css__comma_list_to_style");
    let orig_ctx = *ctx;
    let mut prev_ctx = orig_ctx;
    let mut token: &css_token;
    let mut first = true;
    let mut value: u32 = 0;

   
   if *ctx >= vector.len() {
        return CSS_INVALID;
    }

    token = &vector[*ctx];
    *ctx += 1;

    loop {
        match token.token_type {
            CSS_TOKEN_IDENT  => {
                match get_value {
                    None => {},
                    Some(get_value_function) => {
                        value = (*get_value_function)(strings , lwc_ref, token , first);
                    }
                }
                match reserved {
                    None => {},
                    Some(reserved_function) => {
                        if !((*reserved_function)(strings , lwc_ref, token)) {
                            *ctx = prev_ctx;
                            let (error , some_string) = css__ident_list_to_string(sheet , lwc_ref, strings , vector , ctx , reserved);
                            match error {
                                CSS_OK => {},
                                _ => {
                                    *ctx = orig_ctx;
                                    return error;
                                }
                            }

                            let snumber = sheet.css__stylesheet_string_add(lwc_ref.lwc_intern_string(some_string.unwrap()));
                            css_stylesheet::css__stylesheet_style_append(style , value);
                            css_stylesheet::css__stylesheet_style_append(style , snumber as u32);
                        }
                        else {
                            css_stylesheet::css__stylesheet_style_append(style , value);
                        }
                    }
                }
            },
            CSS_TOKEN_STRING  => {
                match get_value {
                    None => {},
                    Some(get_value_function) => {
                        value = (*get_value_function)(strings , lwc_ref, token , first);
                    }
                }
                let snumber = sheet.css__stylesheet_string_add(token.idata.unwrap());
                css_stylesheet::css__stylesheet_style_append(style , value);
                css_stylesheet::css__stylesheet_style_append(style , snumber as u32);
            },
            _ => {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
        }

        consumeWhitespace(vector , ctx);
        
		if (*ctx >= vector.len()) {
            break;
        }
		
        token = &vector[*ctx];
        if  tokenIsChar(token, lwc_ref,  ',') {
            *ctx = *ctx + 1;
            
			consumeWhitespace(vector , ctx);
            
			if *ctx >= vector.len() {
                *ctx = orig_ctx;
                return CSS_INVALID;
            }
			token = &vector[*ctx]; //peek
            
            match token.token_type {
                CSS_TOKEN_IDENT |CSS_TOKEN_STRING  => {},
                _ => {
                    *ctx = orig_ctx;
                    return CSS_INVALID;
                }
            }
        }
        else {
            break;
        }
        
		first = false;
        
		prev_ctx = *ctx;
        
		if *ctx >= vector.len(){
			break;
		}
		else {
			token = &vector[*ctx];
			*ctx += 1; //Iterate
		}
    }

    CSS_OK
}

/**
* #Arguments:
*  'sheet' -  Stylesheet.

*  'strings' -  css_propstrings.

*  'vector' - Vector of tokens to process.

*  'ctx' - Pointer to vector iteration ctx.

*  'result_style' - resulting style.

*  'side' - 

* #Return Value:
*   'css_error' - CSS_OK on success, 
            CSS_INVALID if the input is not valid

* #Post Condition:
*   ctx is updated with the next token to process
        If the input is invalid, then \a ctx remains unchanged.
*/
pub fn css__parse_border_side(sheet: @mut css_stylesheet, lwc_ref:&mut ~lwc, strings: &css_propstrings , vector: &~[css_token] , ctx: @mut uint , result_style: @mut css_style , side: border_side_e) -> css_error { 
    
    //debug!("Entering: css__parse_border_side");
    let orig_ctx = *ctx;
    let mut prev_ctx: uint;
    let mut color: bool = true;
    let mut style: bool = true;
    let mut width: bool = true;
    let color_style: @mut css_style;
    let style_style: @mut css_style;
    let width_style: @mut css_style;
    let mut token: &css_token;


    if *ctx >= vector.len() {
        return CSS_INVALID;
    }

    token = &vector[*ctx];
    
    if (is_css_inherit(strings, lwc_ref, token)) {
        css_stylesheet::css_stylesheet_style_inherit(result_style , unsafe{transmute(CSS_PROP_BORDER_TOP_COLOR as uint + side as uint)});
        css_stylesheet::css_stylesheet_style_inherit(result_style, unsafe{transmute(CSS_PROP_BORDER_TOP_STYLE as uint + side as uint)});
        css_stylesheet::css_stylesheet_style_inherit(result_style, unsafe{transmute(CSS_PROP_BORDER_TOP_WIDTH as uint + side as uint)});
        *ctx = *ctx + 1;
        return CSS_OK;
    }
    
    color_style = css_stylesheet::css__stylesheet_style_create(sheet);
    style_style = css_stylesheet::css__stylesheet_style_create(sheet);
    width_style = css_stylesheet::css__stylesheet_style_create(sheet);

     let mut error:css_error;
    /* Attempt to parse the various longhand properties */
    loop {
        prev_ctx = *ctx;
        error = CSS_OK;
        
        if *ctx >= vector.len() {
            *ctx = orig_ctx;
            return CSS_INVALID
        }
        
        token = &vector[*ctx];
        
        if is_css_inherit(strings, lwc_ref, token) {
            *ctx = orig_ctx;
            return CSS_INVALID;
        }

        /* Try each property parser in turn, but only if we
         * haven't already got a value for this property.
         */
        if color && 
            match css__parse_border_side_color(sheet, lwc_ref, strings, vector, ctx, color_style, 
                unsafe { transmute(CSS_PROP_BORDER_TOP_COLOR as uint + side as uint)}) { CSS_OK =>{error = CSS_OK; true}, err =>{ error = err; false} } {
                //debug!("css__parse_border :: inside if color");
            color = false
        } 
        else if style && 
            match css__parse_border_side_style(sheet, lwc_ref, strings, vector, ctx, style_style, 
                unsafe {transmute( CSS_PROP_BORDER_TOP_STYLE as uint + side as uint)}) { CSS_OK =>{error = CSS_OK; true}, err =>{ error = err; false} } {
                //debug!("css__parse_border :: inside if style");
            style = false
        } else if width && 
            match css__parse_border_side_width(sheet, lwc_ref, strings, vector, ctx, width_style, 
                unsafe { transmute(CSS_PROP_BORDER_TOP_WIDTH as uint + side as uint)}) { CSS_OK =>{error = CSS_OK; true}, err =>{ error = err; false} } {
            //debug!("css__parse_border :: inside if width");
            width = false
        } 

        if match error { CSS_OK => true, _ => false } {
            consumeWhitespace(vector, ctx);

            if *ctx >= vector.len() {
                break;
            }
        
        } else {
            /* Forcibly cause loop to exit */
            break;
        }
        
        if *ctx == prev_ctx {
            break
        }
    }

    if (style) {
        css_stylesheet::css__stylesheet_style_appendOPV(style_style, unsafe {transmute(CSS_PROP_BORDER_TOP_STYLE as uint + side as uint)}, 0, BORDER_STYLE_NONE);
    }

    if (width) {
        css_stylesheet::css__stylesheet_style_appendOPV(width_style, unsafe {transmute(CSS_PROP_BORDER_TOP_WIDTH as uint + side as uint)}, 0, BORDER_WIDTH_MEDIUM);
       
    }

    css_stylesheet::css__stylesheet_merge_style(result_style, color_style);
    
    css_stylesheet::css__stylesheet_merge_style(result_style, style_style);
    
    css_stylesheet::css__stylesheet_merge_style(result_style, width_style);

    CSS_OK
}


/*******************************************************************************
Moved Autogenerated Parse/Properties functions for removing circular dependency
*********************************************************************************/
/**
* #Arguments:
*  'sheet' -  Stylesheet.

*  'strings' -  css_propstrings.

*  'vector' - Vector of tokens to process.

*  'ctx' - Pointer to vector iteration ctx.

*  'result' - resulting style.

* #Return Value:
*   'css_error' - CSS_OK on success, 
            CSS_INVALID if the input is not valid

* #Post Condition:
*   ctx is updated with the next token to process
        If the input is invalid, then \a ctx remains unchanged.
*/
pub fn css__parse_border_top(sheet:@mut css_stylesheet, lwc_ref:&mut ~lwc,  strings:&css_propstrings,
      vector:&~[css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side(sheet, lwc_ref, strings, vector, ctx, result, BORDER_SIDE_TOP)
}
 

/**
* #Arguments:
*  'sheet' -  Stylesheet.

*  'strings' -  css_propstrings.

*  'vector' - Vector of tokens to process.

*  'ctx' - Pointer to vector iteration ctx.

*  'result' - resulting style.

*  'side' - 
* #Return Value:
*   'css_error' - CSS_OK on success, 
            CSS_INVALID if the input is not valid

* #Post Condition:
*   ctx is updated with the next token to process
        If the input is invalid, then \a ctx remains unchanged.
*/
pub fn css__parse_border_bottom(sheet:@mut css_stylesheet, lwc_ref:&mut ~lwc, strings:&css_propstrings,
      vector:&~[css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side(sheet, lwc_ref, strings, vector, ctx, result, BORDER_SIDE_BOTTOM)
}


/**
* #Arguments:
*  'sheet' -  Stylesheet.

*  'strings' -  css_propstrings.

*  'vector' - Vector of tokens to process.

*  'ctx' - Pointer to vector iteration ctx.

*  'result' - resulting style.

*  'side' - 

* #Return Value:
*   'css_error' - CSS_OK on success, 
            CSS_INVALID if the input is not valid

* #Post Condition:
*   ctx is updated with the next token to process
        If the input is invalid, then \a ctx remains unchanged.
*/
pub fn css__parse_border_left(sheet:@mut css_stylesheet, lwc_ref:&mut ~lwc, strings:&css_propstrings,
      vector:&~[css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side(sheet, lwc_ref, strings, vector, ctx, result, BORDER_SIDE_LEFT)
}


/**
* #Arguments:
*  'sheet' -  Stylesheet.

*  'strings' -  css_propstrings.

*  'vector' - Vector of tokens to process.

*  'ctx' - Pointer to vector iteration ctx.

*  'result' - resulting style.

*  'side' - 

* #Return Value:
*   'css_error' - CSS_OK on success, 
            CSS_INVALID if the input is not valid

* #Post Condition:
*   ctx is updated with the next token to process
        If the input is invalid, then \a ctx remains unchanged.
*/
pub fn css__parse_border_right(sheet:@mut css_stylesheet, lwc_ref:&mut ~lwc, strings:&css_propstrings,
      vector:&~[css_token], ctx:@mut uint, result:@mut css_style) -> css_error
{
 return css__parse_border_side(sheet, lwc_ref, strings, vector, ctx, result, BORDER_SIDE_RIGHT)
}
